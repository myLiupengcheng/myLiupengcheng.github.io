<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>刘鹏程</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="活着便是为了更好的活着">
<meta property="og:type" content="website">
<meta property="og:title" content="刘鹏程">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="刘鹏程">
<meta property="og:description" content="活着便是为了更好的活着">
<meta property="og:locale" content="中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="刘鹏程">
<meta name="twitter:description" content="活着便是为了更好的活着">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">刘鹏程</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/ppoffice/hexo-theme-alex" title="Fork me on GitHub"></a>
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/01/android-version-Q-storage/">Android Q 应用存储空间限制</a>
          </li>
        
          <li>
            <a href="/2019/01/09/android-Performance-optimization-Memory-jitter-md/">性能优化1 - 内存抖动</a>
          </li>
        
          <li>
            <a href="/2018/11/01/gradle-gradlew/">Android Gradlew编译相关命令</a>
          </li>
        
          <li>
            <a href="/2018/09/03/android-system-job/">Android O 后台限制解决方式</a>
          </li>
        
          <li>
            <a href="/2018/06/15/thread-tools-delayQueue/">线程延时队列DelayQueue</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OutOfMemroy/">OutOfMemroy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradlew/">gradlew</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/关于博主/">关于博主</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/控件/">控件</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本适配/">版本适配</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/绘图技巧/">绘图技巧</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编译/">编译</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 13.33px;">JVM</a> <a href="/tags/OutOfMemroy/" style="font-size: 10px;">OutOfMemroy</a> <a href="/tags/gradlew/" style="font-size: 10px;">gradlew</a> <a href="/tags/http/" style="font-size: 16.67px;">http</a> <a href="/tags/关于博主/" style="font-size: 10px;">关于博主</a> <a href="/tags/协议/" style="font-size: 16.67px;">协议</a> <a href="/tags/并发/" style="font-size: 20px;">并发</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/控件/" style="font-size: 16.67px;">控件</a> <a href="/tags/数据库/" style="font-size: 16.67px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/版本适配/" style="font-size: 13.33px;">版本适配</a> <a href="/tags/算法/" style="font-size: 13.33px;">算法</a> <a href="/tags/绘图技巧/" style="font-size: 16.67px;">绘图技巧</a> <a href="/tags/编译/" style="font-size: 10px;">编译</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main">
  
    <article id="post-me" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/29/me/" class="article-date">
  <time datetime="2016-04-29T02:18:14.000Z" itemprop="datePublished">2016-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/随笔/">随笔</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/29/me/">博客简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>首先欢迎各位，来到本人的博客，如果博客有什么地方说的不对，请发邮件联系笔者，笔者会在第一时间进行改正，希望和大家一起进步。邮箱如下<a href="mailto:1065982915@qq.com" target="_blank" rel="noopener">1065982915@qq.com</a></p>
<h3 id="本人简介"><a href="#本人简介" class="headerlink" title="本人简介"></a>本人简介</h3><p>笔者也和大多数技术宅一样，深爱着编程，追求平滑的用户操作，以及快速的响应速度，一直是笔者的心愿，笔者在技术成长上面遇到的最困难的事，便是技术点网上够多，但是技术体系网上少之又少，所以自己想做一些专题，从最开始的到最后的技术难d点全部攻破。现在还在研究。本博客的技术体系，会慢慢的建立起来。 希望大家给予鼓励。因为在技术的道路上面，是迷茫和寂寞的。</p>
<p>爱好：写作，摄影 有相同爱好的小伙伴，可以发邮件一起玩哦</p>
<h3 id="博客目录"><a href="#博客目录" class="headerlink" title="博客目录"></a>博客目录</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul>
<li>并发相关<ul>
<li>基础相关<ul>
<li><a href="https://myliupengcheng.github.io/2018/05/09/thread-base-01/" target="_blank" rel="noopener">线程 - 01 - 基础</a></li>
<li><a href="https://myliupengcheng.github.io/2018/05/09/thread-base-02/" target="_blank" rel="noopener">线程 - 02 - 基础</a></li>
<li><a href="https://myliupengcheng.github.io/2018/05/09/thread-base-03/" target="_blank" rel="noopener">线程 - 03 - 资源共享</a></li>
<li><a href="https://myliupengcheng.github.io/2018/05/09/thread-base-04/" target="_blank" rel="noopener">线程 - 04 - 线程的销毁</a></li>
<li><a href="https://myliupengcheng.github.io/2018/05/13/thread-base-05/" target="_blank" rel="noopener">线程 - 05 - 线程的协作</a></li>
</ul>
</li>
<li>工具相关<ul>
<li><a href="https://myliupengcheng.github.io/2018/05/29/thread-tools-CountDownLatch/" target="_blank" rel="noopener">线程同步工具类 - CountDownLatch</a></li>
<li><a href="https://myliupengcheng.github.io/2018/05/29/thread-tools-CyclicBarrier/" target="_blank" rel="noopener">线程同步工具类 - CyclicBarrier</a></li>
<li><a href="https://myliupengcheng.github.io/2018/06/15/thread-tools-delayQueue/" target="_blank" rel="noopener">线程延时队列 - DelayQueue</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul>
<li><a href="https://myliupengcheng.github.io/2018/06/03/JVM-memory-01/" target="_blank" rel="noopener">JVM学习1 - 内存区域</a></li>
<li><a href="https://myliupengcheng.github.io/2018/06/15/JVM-outofMemroyError-02/" target="_blank" rel="noopener">JVM学习2 - OutOfMemroyError</a></li>
</ul>
<hr>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><a href="https://myliupengcheng.github.io/2017/07/28/dataType-adt-01/" target="_blank" rel="noopener">数据结构表（ADT）解析(上)</a></li>
<li><a href="https://myliupengcheng.github.io/2017/07/29/dataType-adt-02/" target="_blank" rel="noopener">数据结构表（ADT）解析(下)</a></li>
</ul>
<hr>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li><a href="https://myliupengcheng.github.io/2018/05/09/algorithm-OrnamentalGrden/" target="_blank" rel="noopener">装饰者花园</a></li>
<li><a href="https://myliupengcheng.github.io/2018/05/29/algorithm-Philosopher/" target="_blank" rel="noopener">哲学家就餐</a></li>
</ul>
<hr>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ul>
<li><a href="https://myliupengcheng.github.io/2018/05/12/design-patterns23-flyweight-0/" target="_blank" rel="noopener">享元模式-对象池</a></li>
</ul>
<hr>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul>
<li><a href="https://myliupengcheng.github.io/2016/12/02/protocol-http01/" target="_blank" rel="noopener">HTTP - 01 - 基础学习</a></li>
<li><a href="https://myliupengcheng.github.io/2016/12/05/protocol-http02/" target="_blank" rel="noopener">HTTP - 02 - 报文中的HTTP信息</a></li>
<li><a href="https://myliupengcheng.github.io/2016/12/09/protocol-http03/" target="_blank" rel="noopener">HTTP - 03 - Http状态码</a></li>
</ul>
<hr>
<h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><ul>
<li>SQL相关<ul>
<li><a href="https://myliupengcheng.github.io/2018/02/05/android-sqlite01/" target="_blank" rel="noopener">Android数据库（1）、SQLite数据库介绍</a></li>
<li><a href="https://myliupengcheng.github.io/2018/02/06/android-sqlite02/" target="_blank" rel="noopener">Android数据库（2）、SQLite数据库常用的数据结构</a></li>
<li><a href="https://myliupengcheng.github.io/2018/02/08/android-sqlite03/" target="_blank" rel="noopener">Android数据库（3）、Android对SQLite数据库的支持</a></li>
</ul>
</li>
<li>UI相关<ul>
<li>绘图技巧<ul>
<li><a href="https://myliupengcheng.github.io/2017/08/01/android-UI-drawing-drawable-01/" target="_blank" rel="noopener">Drawable的基础用法</a></li>
<li><a href="https://myliupengcheng.github.io/2017/08/04/android-UI-drawing-drawable-02/" target="_blank" rel="noopener">Drawable的进阶用法</a></li>
<li><a href="https://myliupengcheng.github.io/2017/08/05/android-UI-drawing-bitmap-01/" target="_blank" rel="noopener">Bitmap的基础用法</a></li>
</ul>
</li>
<li>控件相关<ul>
<li><a href="https://myliupengcheng.github.io/2017/03/02/android-view-webView01/" target="_blank" rel="noopener">webView的简单使用</a></li>
<li><a href="https://myliupengcheng.github.io/2017/03/06/android-view-SurfaceView01/" target="_blank" rel="noopener">SurfaceView的简单使用</a></li>
<li><a href="https://myliupengcheng.github.io/2017/03/03/android-view-textview/" target="_blank" rel="noopener">TextView优雅显示长文本、富文本</a></li>
</ul>
</li>
</ul>
</li>
<li>版本适配<ul>
<li><a href="https://myliupengcheng.github.io/2018/09/03/android-system-job/" target="_blank" rel="noopener">Android O 后台限制解决方式</a></li>
</ul>
</li>
<li>性能优化<ul>
<li><a href="https://myliupengcheng.github.io/2019/01/09/android-Performance-optimization-Memory-jitter-md/" target="_blank" rel="noopener">内存抖动</a></li>
</ul>
</li>
</ul>
<h4 id="持续更新中-····"><a href="#持续更新中-····" class="headerlink" title="持续更新中 ····"></a>持续更新中 ····</h4><hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>现在博客内容还比较稀少，笔者相信以后的博客会越来越全面的，笔者最近在研究Gradle编译相关知识，如果有什么最新的技术，可以发邮件给笔者，笔者会研究，最后会考虑是否写成专题。   </p>
<p>最后祝大家，早日富可敌国。    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/29/me/" data-id="ck2opn4ip00090mew6xlumh6e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/关于博主/">关于博主</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-version-Q-storage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/android-version-Q-storage/" class="article-date">
  <time datetime="2019-04-01T15:31:39.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/android-version-Q-storage/">Android Q 应用存储空间限制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="应用存储空间限制"><a href="#应用存储空间限制" class="headerlink" title="应用存储空间限制"></a>应用存储空间限制</h2><h3 id="1、背景介绍"><a href="#1、背景介绍" class="headerlink" title="1、背景介绍"></a>1、背景介绍</h3><p>Android 相比于 IOS 来说，外部存储一直都是很混乱的，为了改变相应的这种生态，Android Q 版本对此进行了大量的整改，使用更加精细的划分模式来最大程度的给予App更高的隐私性。</p>
<h4 id="1、适配范围"><a href="#1、适配范围" class="headerlink" title="1、适配范围"></a>1、适配范围</h4><p>应用存储空间限制仅适用于以 Android Q 为目标的应用程序，（targetSDK = 28） 或者在运行Android Q的设备上新安装的应用。</p>
<p>当满足以下每个条件时，系统会将应用程序的文件访问权限置于兼容模式：</p>
<ul>
<li>1、您的应用针对Android 9（API级别28）或更低版本。</li>
<li>2、您的应用安装在从Android 9升级到Android Q的设备上。</li>
</ul>
<h3 id="2、整改内容"><a href="#2、整改内容" class="headerlink" title="2、整改内容"></a>2、整改内容</h3><h4 id="1、每个应用程序持有私有文件的独立存储沙箱"><a href="#1、每个应用程序持有私有文件的独立存储沙箱" class="headerlink" title="1、每个应用程序持有私有文件的独立存储沙箱"></a>1、每个应用程序持有私有文件的独立存储沙箱</h4><p>每个App，Android Q 都会创建一个独立的存储沙箱，限制其他应用程序访问您的应用程序的外部存储设备上的文件。常见的外部存储设备是/sdcard，</p>
<p>该方案具有以下优点：</p>
<ul>
<li>需要更少的权限。应用程序沙箱中的文件对您的应用程序是私有的。因此，不再需要权限在外部存储中访问、保存自己的文件。（READ_EXTERNAL_STORAGE，WRITE_EXTERNAL_STORAGE）</li>
<li>相对于设备上的其他应用程序，隐私性更强。没有其他应用可以直接访问您应用的独立存储沙箱中的文件。此访问限制使您的应用程序更容易维护沙盒文件的隐私。</li>
</ul>
<p>注意：如果用户卸载了您的应用，则会清除隔离存储沙箱中的文件。（这点有点类似于 IOS）</p>
<p>获取 Android Q 为每一个 App 分享的独立存储沙箱，可以调用如下方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context.getExternalFilesDir(String type)</span><br></pre></td></tr></table></figure>
<p>而type的取值为以下这几种</p>
<ul>
<li>{@link android.os.Environment#DIRECTORY_MUSIC},</li>
<li>{@link android.os.Environment#DIRECTORY_PODCASTS},</li>
<li>{@link android.os.Environment#DIRECTORY_RINGTONES},</li>
<li>{@link android.os.Environment#DIRECTORY_ALARMS},</li>
<li>{@link android.os.Environment#DIRECTORY_NOTIFICATIONS},</li>
<li>{@link android.os.Environment#DIRECTORY_PICTURES}, or</li>
<li>{@link android.os.Environment#DIRECTORY_MOVIES}.</li>
</ul>
<h4 id="2、每个应用程序持有公共媒体的共享集合"><a href="#2、每个应用程序持有公共媒体的共享集合" class="headerlink" title="2、每个应用程序持有公共媒体的共享集合"></a>2、每个应用程序持有公共媒体的共享集合</h4><p>每个App，Android Q 都会创建出一个公共的存储区域，供里面的文件独立于 App 之外，当 App 卸载以后，保留该文件，例如：通过 App 下载下来的音乐文件，在这个区域，当你的app需要修改和读取由该APP创建的文件，则不需要任何权限，而如果需要读取和修改其他App创建的文件，则需要申请权限。关于具体权限如下所示：</p>
<ul>
<li>读取 Photos 相关文件，则需要 READ_MEDIA_IMAGES</li>
<li>读取 Videos 相关文件，则需要 READ_MEDIA_VIDEO</li>
<li>读取 Music 相关文件，则需要 READ_MEDIA_AUDIO</li>
</ul>
<p>关于上述，还有两个比较特殊的存在</p>
<ul>
<li>There’s no permission for accessing the Downloads shared collection. Your app can access its own files in this collection. To access other apps’ files in this collection, however, you must allow the user to choose a file using the system’s file picker app.</li>
<li>If your app uses the Storage Access Framework, it doesn’t need to request these media-scoped permissions.</li>
</ul>
<h5 id="1、访问共享集合"><a href="#1、访问共享集合" class="headerlink" title="1、访问共享集合"></a>1、访问共享集合</h5><p>APP 申请了相应的权限以后，可以使用 MediaStore API 来访问这些共享文件。</p>
<ul>
<li>对于 Photos 相关文件，使用 MediaStore.Images</li>
<li>对于 Videos 相关文件，使用 MediaStore.Video.</li>
<li>对于 Music 相关文件，使用 MediaStore.Audio.</li>
<li>对于 Downloads 相关文件，使用 MediaStore.Downloads.</li>
</ul>
<p>适配点 ： 在 Android Q 版本之后，调用 System 提供的 getExternalStoragePublicDirectory（）方法，只会返回该 APP 的独立沙盒目录，要完成适配，则要一直持有 READ_MEDIA_* 权限，然后更新你的存储框架即可。</p>
<p>要访问手机当中的媒体文件，请使用MediaStore检索该文件，然后通过相应的文件描述符就可以访问该文件</p>
<h5 id="2、APP-文件写入共享集合"><a href="#2、APP-文件写入共享集合" class="headerlink" title="2、APP 文件写入共享集合"></a>2、APP 文件写入共享集合</h5><p>Android Q 版本上，当用户卸载 App 的时候，System 会清除 App 所包含的数据，（包含 system 提供给 APP 的独立存储沙箱），如果 APP 想在卸载 APP 后保存部分数据的话，就需要将文件保存在共享集合当中。如何将文件写入共享集合？</p>
<p>使用 MediaStore 集合中插入新行，使用以下方式填充其列</p>
<ul>
<li>1、为 DISPLAY_NAME 和 MIME_TYPE 列提供值</li>
<li>2、您可以使用 PRIMARY_DIRECTORY 和 SECONDARY_DIRECTORY 列来影响文件在磁盘上的放置位置</li>
<li>3、保持 DATA 列未定义。这样，该平台可以灵活地将文件保存在沙箱之外.</li>
<li><p>4、使用API ContentResolver.openFileDescriptor()来读取或写入新创建的文件的数据</p>
<p>但是，如果用户稍后重新安装了 APP ，则 APP 无法访问这些文件，情况类似于应用程序尝试访问其他应用程序文件的情况</p>
</li>
</ul>
<h5 id="3、访问其他应用创建的文件"><a href="#3、访问其他应用创建的文件" class="headerlink" title="3、访问其他应用创建的文件"></a>3、访问其他应用创建的文件</h5><p>要访问和读取其他应用程序已保存到外部存储设备的媒体文件，请完成以下步骤：</p>
<ul>
<li>1、权限</li>
<li>2、使用ContentResolver对象查找并打开文件， 请关注（ContentResolver loadThumbnail 方法）</li>
</ul>
<h5 id="4、写入其他应用创建的文件"><a href="#4、写入其他应用创建的文件" class="headerlink" title="4、写入其他应用创建的文件"></a>4、写入其他应用创建的文件</h5><p>通过将文件保存到共享集合，您的应用程序将成为该文件的所有者。通常，只有当您是文件所有者时，您的应用才能写入共享集合中的文件。但是，如果您的应用程序充当特定用例的用户默认应用程序，您还可以写入其他应用程序拥有的文件</p>
<ul>
<li>1、如果您的应用是用户的默认Photo Manager应用，则可以修改其他应用保存到“ 照片和视频”共享集合中的图像文件。</li>
<li>2、如果您的应用是用户的默认音乐应用，则可以修改其他应用保存到音乐共享收藏集的音频文件。</li>
</ul>
<p>==注意：无论是默认的照片管理器还是音乐应用，您的应用都应保持正常运行。==</p>
<p>要修改其他应用最初保存到外部存储设备的媒体文件，请使用ContentResolver对象查找文件并进行就地修改。执行编辑/修改操作时，请捕获， RecoverableSecurityException以便您可以请求用户授予您对该特定项目的写入权限。</p>
<h4 id="3、APP-访问媒体文件"><a href="#3、APP-访问媒体文件" class="headerlink" title="3、APP 访问媒体文件"></a>3、APP 访问媒体文件</h4><h5 id="1、访问照片-（注意事项）"><a href="#1、访问照片-（注意事项）" class="headerlink" title="1、访问照片 （注意事项）"></a>1、访问照片 （注意事项）</h5><p>Android Q 增加了一些功能，使用户可以更好地控制在外部存储上访问照片的方式。总所周知，在图片文件当中会包含一些 Exif 元数据，通过这些数据，可以访问关于照片的一些详细信息，例如图片的位置信息，而在 Q 版本之上，为了更加安全的保护用户的隐私，对这些 Exif 元数据做了一定的限制。</p>
<p>==如果在 Android 的 System Package Manager 当中。你的应用是默认的 Photos Manager 应用，那么 System会自动让你的应用访问这些照片的位置信息==</p>
<p>除了上述着一种特殊情况，默认其他的应用如果需要访问图片的位置信息，需要满足以下两种情况</p>
<ul>
<li>1、权限 ACCESS_MEDIA_LOCATION</li>
<li>2、从MediaStore对象，调用setRequireOriginal()，传入照片的URI。</li>
</ul>
<p>例如，以下代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Uri photoUri = Uri.withAppendedPath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, cursor.getString(idColumnIndex));</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span>[] latLong;</span><br><span class="line"><span class="keyword">if</span> (BuildCompat.isAtLeastQ()) &#123;</span><br><span class="line">    photoUri = MediaStore.setRequireOriginal(photoUri);</span><br><span class="line">    InputStream stream = getContentResolver().openInputStream(photoUri);</span><br><span class="line">    <span class="keyword">if</span> (stream != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ExifInterface exifInterface = <span class="keyword">new</span> ExifInterface(stream);</span><br><span class="line">        <span class="keyword">double</span>[] returnedLatLong = exifInterface.getLatLong();</span><br><span class="line">        latLong = returnedLatLong != <span class="keyword">null</span> ? returnedLatLong : <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">2</span>];</span><br><span class="line">        stream.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        latLong = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    latLong = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;cursor.getFloat(latitudeColumnIndex), cursor.getFloat(longitudeColumnIndex)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您的应用是相机应用，则它无法直接访问照片和视频共享集中保存的照片，除非它是设备的默认Photo Manager应用。要将用户定向到图库应用，请使用 ACTION_REVIEW意图</p>
<h5 id="2、访问媒体文件-（注意事项）"><a href="#2、访问媒体文件-（注意事项）" class="headerlink" title="2、访问媒体文件 （注意事项）"></a>2、访问媒体文件 （注意事项）</h5><p>应用需要访问特定的媒体文件，例如其他应用分享文件给该应用，或需要访问来自用户媒体集的文件。在这些情况下，优先获取文件的uri，然后通过 content resolver 获取文件描述符。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Uri contentUri = ContentUris.withAppendedId(android.provider.MediaStore.</span><br><span class="line">        Audio.Media.EXTERNAL_CONTENT_URI, cursor.getLong(Integer.parseInt(BaseColumns._ID)));</span><br><span class="line">String fileOpenMode = <span class="string">"r"</span>;</span><br><span class="line">ParcelFileDescriptor parcelFd = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parcelFd = <span class="keyword">this</span>.getContentResolver().openFileDescriptor(contentUri, fileOpenMode);</span><br><span class="line">    <span class="keyword">if</span> (parcelFd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = parcelFd.detachFd();</span><br><span class="line">        <span class="comment">// 获取到相应的文件描述符以后，即可以操作该文件。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">// 错误处理（文件没有找到）</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 清理操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-、访问特定文件"><a href="#3-、访问特定文件" class="headerlink" title="3    、访问特定文件"></a>3    、访问特定文件</h5><p>在某些用例中，您的应用可能需要打开或创建无权访问的文件：</p>
<ul>
<li>1、在照片编辑应用中，打开一张图纸。</li>
<li>2、在业务生产力应用程序中，将文本文档保存到用户选择的位置。</li>
</ul>
<p>对于这些情况，请使用存储访问框架，该框架允许用户选择要打开的特定文件，或选择特定位置来保存文件。</p>
<h4 id="4、外部存储设备"><a href="#4、外部存储设备" class="headerlink" title="4、外部存储设备"></a>4、外部存储设备</h4><p>在Android 9（API级别28）及更低版本中，所有存储设备上的所有文件都显示在单个”external”卷（主卷 – 类似于Windows上面的C盘）名称下。Android Q为每个外部存储设备提供唯一的卷名。此命名系统可帮助您有效地组织和索引内容，并使您可以控制新内容的存储位置。</p>
<p>要唯一标识外部存储中的特定文件，必须同时使用卷名和ID。例如，</p>
<ul>
<li>主存储设备上的文件将是content://media/external/images/media/12，</li>
<li>但是被调用的辅助存储设备上的相应文件FA23-3E92将是 content://media/FA23-3E92/images/media/12。</li>
</ul>
<p>您可以通过将此卷名称传递到特定的媒体集合来访问存储在特定卷上的文件，例如 MediaStore.Images.getContentUri()。</p>
<h5 id="1、获取外部存储设备列表"><a href="#1、获取外部存储设备列表" class="headerlink" title="1、获取外部存储设备列表"></a>1、获取外部存储设备列表</h5><p>要获取所有当前可用卷的名称列表，请调用 MediaStore.getAllVolumeNames()，如以下代码段所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; volumeNames = MediaStore.getAllVolumeNames(context);</span><br></pre></td></tr></table></figure>
<h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><p>设置虚拟外部存储设备</p>
<p>在没有可移动外部存储的设备上，使用以下命令启用虚拟磁盘以进行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell sm set-virtual-disk true</span><br></pre></td></tr></table></figure>
<p>为了帮助您使应用程序与此新行为更改兼容，该平台提供了多种方法来调整与更改相关的多个参数。</p>
<p>切换行为更改<br>要在Android Q Beta 1中启用此行为更改，请在终端窗口中执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell sm set-isolated-storage on</span><br></pre></td></tr></table></figure>
<p>运行此命令后，设备将重新启动。如果没有，请等一下再尝试再次运行该命令。</p>
<p>要确认行为更改已生效，请使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop sys 。isolated_storage_snapshot</span><br></pre></td></tr></table></figure>
<p>测试兼容模式行为<br>测试应用程序时，可以 通过在终端窗口中运行以下命令来启用外部文件存储访问的兼容性模式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd appops设置your-package-name android：legacy_storage allow</span><br></pre></td></tr></table></figure>
<p>要禁用兼容模式，请在Android Q上卸载并重新安装您的应用，或在终端窗口中运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd appops设置your-package-name android：legacy_storage default</span><br></pre></td></tr></table></figure>
<h3 id="4、特性总结"><a href="#4、特性总结" class="headerlink" title="4、特性总结"></a>4、特性总结</h3><ul>
<li><ol>
<li>Android Q 为每个应用程序在外部存储设备提供了一个独立的存储沙箱，应用通过路径创建的文件都保存在应用的沙箱目录</li>
</ol>
</li>
<li><ol start="2">
<li>共享集合：如果应用的一些文件是用户选择下载保存的，应用卸载的时候用户不希望删除，这部分文件开发者可以通过MediaProvider接口保存在公共共享集合，包括：照片、视频、音乐和下载集合</li>
</ol>
</li>
<li><ol start="3">
<li>新的访问多媒体文件的权限：应用读写自己创建的文件不需要权限，但是如果需要读取其他应用创建的多媒体文件就需要申请对应的权限，通过MediaProvider接口读取</li>
</ol>
</li>
<li><ol start="4">
<li>读写其他应用的下载公共集合文件需要使用SAF的方式读写</li>
</ol>
</li>
<li><ol start="5">
<li>目前版本该特性没有默认开启，需要开发者通过命令开启：adbshell smset-isolated-storage on</li>
</ol>
</li>
<li><ol start="6">
<li>参考谷歌提供的官方适配指导文档：<a href="https://developer.android.google.cn/preview/privacy/scoped-storage" target="_blank" rel="noopener">https://developer.android.google.cn/preview/privacy/scoped-storage</a></li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/android-version-Q-storage/" data-id="ck2opn4jt00250mew8xy5qv9l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/版本适配/">版本适配</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-Performance-optimization-Memory-jitter-md" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/09/android-Performance-optimization-Memory-jitter-md/" class="article-date">
  <time datetime="2019-01-09T12:40:25.000Z" itemprop="datePublished">2019-01-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/09/android-Performance-optimization-Memory-jitter-md/">性能优化1 - 内存抖动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>什么是内存抖动</li>
<li>内存抖动的影响</li>
<li>引起内存抖动的原因</li>
<li>如何发现内存抖动</li>
<li>内存抖动常见的解决方式</li>
</ul>
<hr>
<p>Android 是基于 Java ，不管是刚刚接触 Android 的新手，还是混迹在开发前线的老手，都知道在 Android上面的开发，不用管内存的回收，需要对象的时候 new 出来就好了，其余的 GC 会帮助我们，但是 GC 也不是万能的，GC 机制帮助我们的同时，也会限制我们，俗话说有得有失嘛。今天来看一下由于这种机制给我们带来的第一个坑，内存抖动。</p>
<h2 id="什么是内存抖动"><a href="#什么是内存抖动" class="headerlink" title="什么是内存抖动"></a>什么是内存抖动</h2><p>内存回收是指在程序需要对象的时候，在堆当中分配出来一块空间，使用完毕以后，由 GC 帮我们清理掉这片内存空间。如果频繁的一直持续上述操作，就会引起内存抖动。也就是有源源不断的对象被创建，同时又有源源不断的对象被回收。</p>
<h2 id="内存抖动的影响"><a href="#内存抖动的影响" class="headerlink" title="内存抖动的影响"></a>内存抖动的影响</h2><ul>
<li>导致程序卡顿</li>
<li>导致程序内存溢出</li>
</ul>
<p>出现上述情况的内存抖动，会对程序造成什么影响呢，首先我们知道 GC 回收的时候也是需要消耗资源的，比如 GC 回收的时候会停止掉所有的线程，如果触发一次 GC 就停止一次，那如果多次频繁的触发 GC 线程也会一卡一卡的，所以总的来说内存抖动可能会造成程序的卡顿。</p>
<p>如果发生频繁的 GC 会导致出现不连续的内存片无法进行分配，导致 OOM 内存溢出。</p>
<p>注意：Android 垃圾回收机制使用的是 CMS 垃圾回收器 （采用标记 - 清理算法）</p>
<h2 id="引起内存抖动的原因"><a href="#引起内存抖动的原因" class="headerlink" title="引起内存抖动的原因"></a>引起内存抖动的原因</h2><p>内存抖动出现原因主要是频繁在循环里创建对象，导致大量对象在短时间内被创建，由于新对象是要占用内存空间的而且是频繁，如果一次或者两次在循环里创建对象对内存影响不大，不会造成严重内存抖动这样可以接受也不可避免，频繁的话就很内存抖动很严重。</p>
<h2 id="如何发现内存抖动"><a href="#如何发现内存抖动" class="headerlink" title="如何发现内存抖动"></a>如何发现内存抖动</h2><p>首先我们先来看一个简单的 Demo </p>
<p>我们知道 Java 当中的字符串对象是不可变的，如果累加的话。会将原来的 Copy 出来一份。然后进行累加成为新的字符串，原来的就会被回收掉，现在我们就利用这个特性来模拟一个简单的内存抖动现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span> <span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            String tempTestString = <span class="string">"  "</span>;</span><br><span class="line">            <span class="comment">//拼接打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                tempTestString += <span class="string">" ++"</span>;</span><br><span class="line">                tempTestString += <span class="string">" --"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样必然会出现内存抖动，我们通过 AS 自带的工具观察一下内存的使用情况，如下所示：</p>
<p><img src="/2019/01/09/android-Performance-optimization-Memory-jitter-md/android-Performance-optimization-Memory-jitter-md⁩/01.png" alt="内存抖动"></p>
<p>有小白色的垃圾桶，说明触发了 GC ，有一个代表出发了一次 GC ，上图有多个，然后我们选定一个时刻，仔细的看一下对象，例如下图</p>
<p><img src="/2019/01/09/android-Performance-optimization-Memory-jitter-md/android-Performance-optimization-Memory-jitter-md⁩/02.jpg" alt="内存抖动"></p>
<p>可以看到对象最多便是char数组，和 String 类型，然后点击 String，随便选取一个实例，查看他的堆栈，双击 便可以定位到我们的代码当中，然后结合详细的代码，进行分析，便可以规避上述的问题。</p>
<p><img src="/2019/01/09/android-Performance-optimization-Memory-jitter-md/android-Performance-optimization-Memory-jitter-md⁩/03.jpg" alt="内存抖动"></p>
<h2 id="内存泄漏常见的解决方式"><a href="#内存泄漏常见的解决方式" class="headerlink" title="内存泄漏常见的解决方式"></a>内存泄漏常见的解决方式</h2><ul>
<li>尽量避免在循环体内创建对象，应该把对象创建移到循环体外。</li>
<li>注意自定义View的onDraw()方法会被频繁调用，所以在这里面不应该频繁的创建对象。</li>
<li>当需要大量使用Bitmap的时候，试着把它们缓存在数组中实现复用。</li>
<li>对于能够复用的对象，同理可以使用对象池将它们缓存起来。</li>
</ul>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://www.cnblogs.com/xgjblog/p/9042458.html" target="_blank" rel="noopener">https://www.cnblogs.com/xgjblog/p/9042458.html</a><br><a href="https://blog.csdn.net/wanghao200906/article/details/79311288" target="_blank" rel="noopener">https://blog.csdn.net/wanghao200906/article/details/79311288</a><br><a href="https://blog.csdn.net/nicolelili1/article/details/89219191" target="_blank" rel="noopener">https://blog.csdn.net/nicolelili1/article/details/89219191</a><br><a href="https://blog.csdn.net/qq_31370269/article/details/52818277" target="_blank" rel="noopener">https://blog.csdn.net/qq_31370269/article/details/52818277</a><br><a href="https://blog.csdn.net/wanghao200906/article/details/79311288" target="_blank" rel="noopener">https://blog.csdn.net/wanghao200906/article/details/79311288</a><br><a href="https://www.youtube.com/watch?v=McAvq5SkeTk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=McAvq5SkeTk</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/09/android-Performance-optimization-Memory-jitter-md/" data-id="ck2opn4ih00050mewbzugg5ys" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能优化/">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gradle-gradlew" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/01/gradle-gradlew/" class="article-date">
  <time datetime="2018-11-01T07:02:26.000Z" itemprop="datePublished">2018-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/01/gradle-gradlew/">Android Gradlew编译相关命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>gradlew 是什么东西呢，和gradle貌似不大一样，肯定有关系。没错，他就是 gradle wrapper，意思是gradle的一个包装，大家可以理解为在这个项目本地就封装了gradle，比如我的项目是HelloWord, 在HelloWord/gradle/wrapper/gralde-wrapper.properties文件中声明了它指向的目录和版本，比如我的内容是：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Thu Nov <span class="number">01</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">47</span> CST <span class="number">2018</span></span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper<span class="regexp">/dists</span></span><br><span class="line"><span class="regexp">zipStoreBase=GRADLE_USER_HOME</span></span><br><span class="line"><span class="regexp">zipStorePath=wrapper/</span>dists</span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-2.2-all.zip</span></span><br></pre></td></tr></table></figure>
<p>如果你项目没有该文件的话，那么gradlew会到~/.gradle/wrapper/dists/gradle-2.10-all下寻找，或者你新建给文件，内容复制到里面。其实你会发现是同一个目录咯。里面会有个随机数的文件夹，里面就是gradle，只要下载成功即可用grdlew wrapper的命令代替全局的gradle命令。</p>
<p>常用命令如下：(linux下是./gradlew，该脚本在项目下，windows直接gradlew即可)</p>
<h3 id="2、命令"><a href="#2、命令" class="headerlink" title="2、命令"></a>2、命令</h3><ul>
<li>./gradlew -v 版本号，首次运行，没有gradle的要下载的哦。</li>
<li>./gradlew clean 删除HelloWord/app目录下的build文件夹</li>
<li>./gradlew build 检查依赖并编译打包<ul>
<li>./gradlew assembleDebug 编译并打Debug包</li>
<li>./gradlew assemblexiaomiDebug 编译并打xiaomi的debug包，其他类似</li>
<li>./gradlew assembleRelease 编译并打Release的包</li>
<li>./gradlew assemblexiaomiRelease 编译并打xiaomi的Release包，其他类似</li>
<li>./gradlew installRelease Release模式打包并安装</li>
<li>./gradlew uninstallRelease 卸载Release模式包</li>
</ul>
</li>
</ul>
<h4 id="gradlew-build-检查依赖并编译打包"><a href="#gradlew-build-检查依赖并编译打包" class="headerlink" title="./gradlew build 检查依赖并编译打包"></a>./gradlew build 检查依赖并编译打包</h4><p>这里注意的是 ./gradlew build 命令把debug、release环境的包都打出来，生成的包在目录HelloWord/app/build/outputs/apk/下。如果正式发布只需要打release的包，</p>
<h5 id="gradlew-build-和-gradle-build-有区别吗"><a href="#gradlew-build-和-gradle-build-有区别吗" class="headerlink" title="gradlew build 和 gradle build 有区别吗?"></a>gradlew build 和 gradle build 有区别吗?</h5><p>使用gradle wrapper是gradle官方推荐的build方式，而gradlew正是运行了wrapper task之后生成的（运行wrapper task是Android Studio自动做的）。使用gralde wrapper的一个好处就是每个项目可以依赖不同版本的gradle，构建的时候gradle wrapper会帮你自动下载所依赖的版本的gradle。而如果你使用gradle build的话，同时你又有多个项目使用不同版本的gradle，那就需要你手动在自己的机器上配置多个版本的gradle，稍微麻烦一些</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.<span class="regexp">/gradlew clean  clean项目</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">./g</span>radlew build  构建项目</span><br><span class="line"> </span><br><span class="line"><span class="regexp">/gradlew assembleDebug or /g</span>radlew aD 编译并打Debug包</span><br><span class="line"> </span><br><span class="line">.<span class="regexp">/gradlew assembleRelease or /g</span>radlew aR 编译并打Release的包</span><br><span class="line"> </span><br><span class="line">.<span class="regexp">/gradlew installRelease or /g</span>radlew iR Release模式打包并安装</span><br><span class="line"> </span><br><span class="line">.<span class="regexp">/gradlew installDebug or /g</span>radlew iD Debug模式打包并安装</span><br><span class="line"> </span><br><span class="line">.<span class="regexp">/gradlew uninstallRelease or ./g</span>radlew uR 卸载Release模式包</span><br><span class="line"> </span><br><span class="line">.<span class="regexp">/gradlew uninstallDebug or ./g</span>radlew uD 卸载Debug模式包</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">需要说明的是这些命令可以叠加使用，例如：</span><br><span class="line"> </span><br><span class="line">.<span class="regexp">/gradlew clean build --info &gt; bugtags.log</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/01/gradle-gradlew/" data-id="ck2opn4iq000a0mewqf9ms9k8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gradlew/">gradlew</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译/">编译</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-system-job" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/03/android-system-job/" class="article-date">
  <time datetime="2018-09-03T15:31:39.000Z" itemprop="datePublished">2018-09-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/03/android-system-job/">Android O 后台限制解决方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>Android O版本上面，Android做了一定的限制，目的就是加快Android的运行速度，导致在Android O版本上面，如果后台组件想要启动服务不允许，这样的操作导致很多应用都需要适配，改动大量的代码，在这里，如果Google官方给出了三种解决方式，AlarmManager、SyncAdapter、JobScheduler来代替服务，这里主要讲解如何使用这这三种方式如何应用</p>
<ul>
<li>AlarmManager </li>
<li>SyncAdapter</li>
<li>JobScheduler</li>
</ul>
<h3 id="2、AlarmManager"><a href="#2、AlarmManager" class="headerlink" title="2、AlarmManager"></a>2、AlarmManager</h3><p>AlarmManager通常用途是用来开发手机闹钟，但是AlarmManager的用处并只是这个。AlarmManager其实是一个全局定时器，它可以在指定时间或指定周期启动其他组件（Activity、Service、BroadcastReceiver),Alarm Manager适用于希望在特定时间运行应用程序代码的情况，即使应用程序当前未运行也是如此。对于正常的定时操作（刻度，超时等），使用起来更容易，更有效.</p>
<h4 id="2-1、AlarmManager使用的一些坑"><a href="#2-1、AlarmManager使用的一些坑" class="headerlink" title="2.1、AlarmManager使用的一些坑"></a>2.1、AlarmManager使用的一些坑</h4><ul>
<li>华为手机上kill应用后，无法唤醒Alarm.  大部分原因都是手机为Alarm设置了统一的唤醒时间</li>
<li>不能精确启动闹钟服务 （API19以上是无法精确时间的）</li>
<li>华为手机上休眠无法启动闹钟服务</li>
</ul>
<h4 id="2-2、AlarmManager的主要方法："><a href="#2-2、AlarmManager的主要方法：" class="headerlink" title="2.2、AlarmManager的主要方法："></a>2.2、AlarmManager的主要方法：</h4><ul>
<li><p>set(int type,long triggerAtTime,PendingIntent operation) ： 设置指定triggerAtTime时间启动由operation参数指定组件</p>
<p>  type ： 定时服务的类型，有以下四种取值 </p>
<ul>
<li>ElAPSED_REALTIME： 指定从现在开始过了一定时间后启动operation所对应的组件。</li>
<li>ELASPED_REALTIME_WAKEUP： 指定从现在开始时间过了一定时间operation所对应的组件。即使系统处于休眠状态也会执行也会执行operation所对应的组件。</li>
<li>RTC： 指定当系统调用System.currentTimeMillis()方法的返回值与triggerAtTime相等时启动operation所对应的组件。</li>
<li>RTC_WAKEUP:指定当系统调用System.currentTimeMillis()方法的返回值与triggerAtTime相等时启动operation对应的组件，即使系统休眠状态也会执行operation所对应的组件。</li>
</ul>
</li>
<li><p>setInexactRepeating(int type,long triggerAtTime,long interval,PendingIntent operation) ： 设置非精确的周期性任务。例如，我们设置Alarm每个小时启动一次，但是系统不一定总在每个小时的开始启动Alarm服务。</p>
</li>
<li>setRepeating(int type,long triggerAtTime,long interval,PendingIntent operation) ：设置一个周期性执行的定时服务。</li>
<li>cancel(PendingIntent operation) ：取消AlarmManager的定时服务。</li>
</ul>
<h4 id="2-3、注意"><a href="#2-3、注意" class="headerlink" title="2.3、注意"></a>2.3、注意</h4><p>API 19(Android4.4)开始，AlarmManager的机制是非准确激发的，操作系统会偏移(shift)闹钟来最小化唤醒和电池消耗。不过AlarManager新增了如下两个方法来支持精确激发。</p>
<ul>
<li>setExact(int type long triggerAtMillis,PendingIntent operation) ：设置闹钟闹钟将在精确的时间被激发。</li>
<li>setWindow(int type,long windowStartMillis,long windowLengthMillis,PendingIntent operation) ：设置闹钟将在精确的时间段内被激发。</li>
</ul>
<p>很显示API19以后无法使用setInexactRepeating()和setRepeating()，也就是无法设置重复闹钟，唯一解决的方式，也只有启动闹钟的时候再设置一次闹钟，也就变相地实现了重复闹钟了。<br>API19以下使用setExact()和setWindow()将会报没有匹配的方法<br>java.lang.NoSuchMethodError: android.app.AlarmManager.setExact  </p>
<p>解决办法是判断SDK版本，根据SDK版本来定义不同的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sdkVersion = Integer.valueOf(Build.VERSION.SDK_INT);</span><br></pre></td></tr></table></figure>
<h4 id="2-4、做一个小Demo，就是通过使用AlarmManager来做一个闹钟的小Demo"><a href="#2-4、做一个小Demo，就是通过使用AlarmManager来做一个闹钟的小Demo" class="headerlink" title="2.4、做一个小Demo，就是通过使用AlarmManager来做一个闹钟的小Demo"></a>2.4、做一个小Demo，就是通过使用AlarmManager来做一个闹钟的小Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">MainActivity.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    findViewById(R.id.setDate).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            Calendar currentTime = Calendar.getInstance();</span><br><span class="line">            <span class="keyword">new</span> TimePickerDialog(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> TimePickerDialog.OnTimeSetListener() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.KITKAT)</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeSet</span><span class="params">(TimePicker view, <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minute)</span> </span>&#123;</span><br><span class="line">                    Intent i=<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,AlarmActivity.class);</span><br><span class="line">                    <span class="comment">//创建PendingIntent对象</span></span><br><span class="line">                    PendingIntent pi=PendingIntent.getActivity(MainActivity.<span class="keyword">this</span>,<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">                    Calendar c=Calendar.getInstance();</span><br><span class="line">                    c.setTimeInMillis(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//Calendar.HOUR这是12小时制因为无论你的TimePickerDialog设置的是12还是24，hourOfDay默认获取的是24小时制的  </span></span><br><span class="line">                    <span class="comment">//根据用户的选择的时间来设置Calendar对象 c.set(Calendar.HOUR_OF_DAY,hourOfDay);</span></span><br><span class="line">                    c.set(Calendar.MINUTE,minute);</span><br><span class="line">                    <span class="comment">//获取AlarmManager</span></span><br><span class="line">                    AlarmManager am= (AlarmManager) getSystemService(ALARM_SERVICE);</span><br><span class="line">                    Log.i(TAG, <span class="string">"onTimeSet: "</span>+SystemInfoUtil.getSDKVersionNumber());</span><br><span class="line">                    <span class="keyword">if</span> (SystemInfoUtil.getSDKVersionNumber()&gt;=<span class="number">19</span>)&#123;</span><br><span class="line">                    <span class="comment">//API19以上使用</span></span><br><span class="line">                        am.setExact(AlarmManager.RTC_WAKEUP,c.getTimeInMillis(),pi);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        am.set(AlarmManager.RTC_WAKEUP,c.getTimeInMillis(),pi);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"设置闹钟成功"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,currentTime.get(Calendar.HOUR_OF_DAY),currentTime.get(Calendar.MINUTE),<span class="keyword">false</span>).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AlarmActivity.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_alarm);</span><br><span class="line">    <span class="comment">// 加载音乐</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//      String path = RingtoneManager.getActualDefaultRingtoneUri(this, RingtoneManager.TYPE_RINGTONE).getPath();</span></span><br><span class="line">        AssetFileDescriptor openFd=getAssets().openFd(<span class="string">"music.mp3"</span>);</span><br><span class="line">        AudioPlayer.getInstance().play(openFd);</span><br><span class="line">        AudioPlayer.getInstance().setLooping(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">            .setTitle(<span class="string">"闹钟"</span>)</span><br><span class="line">            .setTitle(<span class="string">"时间到！！！！！ "</span>)</span><br><span class="line">            .setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                    AudioPlayer.getInstance().stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .create().show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、SyncAdapter"><a href="#3、SyncAdapter" class="headerlink" title="3、SyncAdapter"></a>3、SyncAdapter</h3><p><a href="https://developer.android.com/training/sync-adapters/creating-sync-adapter" target="_blank" rel="noopener">https://developer.android.com/training/sync-adapters/creating-sync-adapter</a></p>
<h3 id="4、JobScheduler"><a href="#4、JobScheduler" class="headerlink" title="4、JobScheduler"></a>4、JobScheduler</h3><p>Android 不允许后台服务启动服务，所以官方推荐使用JobScheduler来代替原有的后台监视服务，在很多情况下，应用都可以使用 JobScheduler 作业替换后台服务。 例如，CoolPhotoApp 需要检查用户是否已经从朋友那里收到共享的照片，即使该应用未在前台运行。8.0以前应用使用一种会检查其云存储的后台服务。 为了迁移到 Android 8.0，开发者使用一个计划作业替换了这种后台服务，该作业将按一定周期启动，查询服务器，然后退出</p>
<p>Android 5.0的时候，Google就开始提倡使用该工作分发器来优化电量等资源，随着6.0、7.0、8.0版本的到来，JobScheduler慢慢代替后台服务的运行，JobScheduler到底应该如何使用呢？</p>
<p>开发者需要在稍后的某个时间点或者满足某个特定的条件时去执行某个任务，例如当设备开始充电，或者网络状态连接到wifi状态时执行某些推送通知的任务，jobscheduler就是用来处理这类场景的任务。 </p>
<p>Jobscheduler的android在5.0上针对于降低功耗而提出来的一种策略方案，自 Android 5.0 发布以来，JobScheduler 已成为执行后台工作的首选方式，其工作方式有利于用户。应用可以在安排作业的同时允许系统基于设备状态、电源和连接情况等具体条件进行优化。JobScheduler 可实现控制和简洁性，谷歌推出该机制是想要所有应用在执行后台任务时使用它。（还有一点需要注意的是，在7.0上谷歌给出建议：在 Android 7.0 中，删除了三个常用隐式广播 —CONNECTIVITY_ACTION、ACTION_NEW_PICTURE 和ACTION_NEW_VIDEO— 因为这些广播可能会一次唤醒多个应用的后台进程，同时会耗尽内存和电量。如果应用需要收到这些广播，充分利用 Android 7.0 以迁移到 JobScheduler 和相关的 API。</p>
<h4 id="4-1、如何使用Job"><a href="#4-1、如何使用Job" class="headerlink" title="4.1、如何使用Job"></a>4.1、如何使用Job</h4><p>应用如果想使用JobScheduler API的话，首先需要创建自己需要执行的任务信息，创建任务的方法在谷歌官方文档上已经有详细介绍，这里只是放出一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JobScheduler scheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);  </span><br><span class="line"> ComponentName jobService = <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, MyJobService.class);</span><br><span class="line"> JobInfo jobInfo = <span class="keyword">new</span> JobInfo.Builder(<span class="number">100012</span>, jobService) <span class="comment">//任务Id等于100012</span></span><br><span class="line">         .setMinimumLatency(<span class="number">5000</span>)<span class="comment">// 任务最少延迟时间为5s  </span></span><br><span class="line">         .setOverrideDeadline(<span class="number">60000</span>)<span class="comment">// 任务deadline，当到期没达到指定条件也会开始执行  </span></span><br><span class="line">         .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)<span class="comment">// 需要满足网络条件，默认值NETWORK_TYPE_NONE</span></span><br><span class="line">         .setPeriodic(AlarmManager.INTERVAL_DAY) <span class="comment">//循环执行，循环时长为一天（最小为15分钟）</span></span><br><span class="line">         .setRequiresCharging(<span class="keyword">true</span>)<span class="comment">// 需要满足充电状态  </span></span><br><span class="line">         .setRequiresDeviceIdle(<span class="keyword">false</span>)<span class="comment">// 设备处于Idle(Doze)</span></span><br><span class="line">         .setPersisted(<span class="keyword">true</span>) <span class="comment">//设备重启后是否继续执行</span></span><br><span class="line">         .setBackoffCriteria(<span class="number">3000</span>，JobInfo.BACKOFF_POLICY_LINEAR) <span class="comment">//设置退避/重试策略</span></span><br><span class="line">         .build();  </span><br><span class="line"> scheduler.schedule(jobInfo);</span><br></pre></td></tr></table></figure>
<p>上面的一个任务需要满足充电状态，并且设备不出于idle状态，并且需要网络处于非计费类型时，会运行该job，自己在构建自己的job 时候需要按需设置触发条件。但是这里需要注意的一个点是JobScheduler所创建并执行的任务必须是带有条件限制的，不然是违背其初衷的，当你创建一个任务，并且不设置任何限制条件并且直接调用 scheduler.schedule(builder.build());去执行该任务是不可行的，会报以下的异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: You&apos;re trying to build a job with no constraints, this is not allowed.</span><br></pre></td></tr></table></figure>
<ol>
<li>setMinimumLatency(long minLatencyMillis): 设置任务的最小延迟执行时间(单位是毫秒)。 </li>
<li>setOverrideDeadline(long maxExecutionDelayMillis): 设置任务最晚的延迟时间。如果到了规定的时间时其他条件还未满足，你的任务也会被启动。 </li>
<li>setPersisted(boolean isPersisted): 设置当设备重启之后该任务是否还要继续执行。 </li>
<li>setExtras(PersistableBundle extras): 设置传递bundler参数 </li>
<li>setRequiredNetworkType(int networkType):设置需要满足网络类型 </li>
<li>setRequiresCharging(boolean requiresCharging)：设置是否需要充电状态下运行 </li>
<li>setRequiresDeviceIdle(boolean requiresDeviceIdle)：设置是否需要在Idle（Doze）状态下运行（7.0上新加的） </li>
<li>addTriggerContentUri(@NonNull TriggerContentUri uri)：设置监控ContentUri 发生改变时运行（7.0上新加的）</li>
<li>setPeriodic(long intervalMillis):设置循环执行的时长</li>
</ol>
<p>具体条件可以参考Google官方网站，</p>
<p><a href="https://developer.android.com/reference/android/app/job/JobScheduler" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/job/JobScheduler</a></p>
<p>当需要使用JobScheduler 来干实际的任务时，需要新建一个service，来继承JobService（这一点与DreamService类似），而且必须重写其中的两个方法，分别是onStartJob(JobParameters params)和onStopJob(JobParameters params)；<br>在startJob里来执行自己的代码逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJobService</span> <span class="keyword">extends</span> <span class="title">JobService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"MyTest"</span>, <span class="string">"onStartJob @@@@@@@@ "</span> + params);</span><br><span class="line">        jobFinished(params,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的一点是，当做完自己的任务要及时调用JobFinished 来结束自己的任务。在6.0上在如果不调用该接口会造成严重的功耗问题。</p>
<p>当上面创建任务时执行到scheduler.schedule(builder.build()); 则开始准备执行任务，一旦满足设置的条件，便会执行到onStartJob()方法，也就是在我们的任务应该具体事宜应该是放在onStartJob中去做的。该方法返回值为为一个boolean值，如果返回值是false,系统假设这个方法返回时任务已经执行完毕，如果返回值是true,那么系统假定这个任务正要被执行，执行任务的重担就落在了你的肩上（这时候需要去新开一个线程去做事物，文档接口上有起描述）。当任务执行完毕后要调用jobFinished()来通知系统。</p>
<p>当系统受到一个cancel请求时会取消该任务（当该任务未执行将其在pending list删除，如果该任务正在执行则停止其任务）。<br>使用Jobscheduler还需要到AndroidManifest.xml中添加一个service节点让你的应用拥有绑定和使用这个JobService的权限。</p>
<p>&lt;service android:name=”com.example.suansuan.jobtest.MyJobService”<br>android:permission=”android.permission.BIND_JOB_SERVICE” /&gt;</p>
<h4 id="4-2、Job的使用出现的坑"><a href="#4-2、Job的使用出现的坑" class="headerlink" title="4.2、Job的使用出现的坑"></a>4.2、Job的使用出现的坑</h4><ol>
<li>小心JobService运行在主线程：上面已经说明了，当schedule是在主线程调用的，那么jobsevice则运行则主线程，需要小心主线程ANR 以及严苛模式抛出异常 </li>
<li>小心cancelAll(): 该方法的功能是取消该uid下的所有jobs，也就是说当存在多个app通过shareUid的方式，那么在其中任意一个app执行cancalAll()，则会把所有同一uid下的app中的jobs都cancel掉。 </li>
<li>Jobscheduler如果设置了setPersisted(true)，则重启后还会再运行，不能使用HashCode 来做JobId </li>
<li>job执行完了，一定要记得要调用JobFinished</li>
<li>同一个包名下，不能有两个相同的jobId ，如果一个app非常大，两个功能模块为两个程序员维护，则很容易产生沟通不足的情况下，使用了两个相同的JobId，此时只能有一个job生效。另一个无效。该问题可以通过终端命令行： adb shell dumpsys jobscheduler 来查看单个app 的job信息确认</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JobScheduler 虽然是在5.0上新增加的一个新服务，但是从L到M，N以及最新的O 上，谷歌Android也是在重点推荐使用该功能，并且在Android O 上谷歌还推出了一套Android vitals 计划，旨在提高Android 系统的功耗，性能，以及稳定性等相关指标，在对功耗上提出来的建议便是，非精确性的定时任务建议使用Job来代替Alarm，能更加准确的满足条件的执行你想要执行的任务。在Android O上JobScheduler更加完善了其条件控制，加上了低存储，低电量策略下的job运行限制，这里将在后面job服务解析中继续提到</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/03/android-system-job/" data-id="ck2opn4ju00270mewq8pm7ver" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/版本适配/">版本适配</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-thread-tools-delayQueue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/15/thread-tools-delayQueue/" class="article-date">
  <time datetime="2018-06-15T07:19:03.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/并发/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/15/thread-tools-delayQueue/">线程延时队列DelayQueue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>1、DelayQueue的作用</li>
<li>2、DelayQueue使用规则</li>
<li>3、DelayQueue的Demo</li>
<li>4、DelayQueue原理  *</li>
<li>5、DelayQueue的实现 *</li>
</ul>
<hr>
<h3 id="1、DelayQueue的作用"><a href="#1、DelayQueue的作用" class="headerlink" title="1、DelayQueue的作用"></a>1、DelayQueue的作用</h3><p>作用便是线程调度机制通过粒度特别细的时间控制相应的元素在合适的时间出队，使用场景也是非常多的比如：缓存机制当中使用这个队列来控制缓存队列当中的缓存是否过期，如果过期则执行缓存过期以后的相应逻辑。</p>
<h3 id="2、DelayQueue使用规则"><a href="#2、DelayQueue使用规则" class="headerlink" title="2、DelayQueue使用规则"></a>2、DelayQueue使用规则</h3><p>DelayQueue从名字，我们知道是一个队列，并且继承自BlockingQueue，是一个阻塞队列，那么就有着阻塞队列的特点，当队列为空的时候，take方法将阻塞，这里需要注意的便是DelayQueue是一个无届队列，也就意味着，没有当队列为满的时候，所以就没有队满。put/add 阻塞的情况，其次DelayQueue最显著的特点便是，这个队列当中根据时间为优先级对队中的元素进行排序，如果我们take一个元素的时候，这个元素的时间值没有到，便会自动阻塞，当时间到以后take到元素。在DelayQueue这个队列当中所描述的任何一种元素必须实现Delay接口，而这个接口当中便定义了两个方法，我们通过这两个方法来进行队当中的排序，以及take的时候，相应的时间粒度的控制。</p>
<p>时间最长的在对头还是时间最短的在对头，这个主要看如何实现元素的 compareTo 方法。</p>
<ul>
<li>public int compareTo(T o);</li>
<li>long getDelay(TimeUnit unit);</li>
</ul>
<p>这里需要注意的是在getDelay当中获取时间的单位是NANOSECONDS，所以在写getDelay这个方法的时候注意使用的时间单位是NANOSECONDS。</p>
<h3 id="3、DelayQueue的Demo"><a href="#3、DelayQueue的Demo" class="headerlink" title="3、DelayQueue的Demo"></a>3、DelayQueue的Demo</h3><p>下面我们通过一个例子来看一下这个DelayQueue到底应该如何使用。本例子当中我们先根据时间短的先执行，打印了一遍执行顺序，然后通过一个List将原本初始化的时候的Runnable进行了保存，然后在最后进行打印，打印的顺序，便是初始化的顺序，也就是入队的时候的顺序。还有在方括号当中便是延时的时间，可以通过运行看一下，是否是等了相应的时间打印出来的这句话。目的就是让大家可以很直观的看到，我们通过DelayQueue是按照一个什么顺序进行排序的，最后通过一个任务将整个系统结束掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 探究无届队列DelayQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengchengliu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDelayQueue</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"> 		ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"> 		DelayQueue&lt;DelayedTask&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;DelayedTask&gt;();</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">// 初始化 delayQueue ，</span></span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> 			delayQueue.put(<span class="keyword">new</span> DelayedTask(random.nextInt(<span class="number">5000</span>)));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		delayQueue.add(<span class="keyword">new</span> DelayedTask.EndSentinel(<span class="number">5000</span>, newCachedThreadPool));</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">// 启动任务开关</span></span><br><span class="line"> 		newCachedThreadPool.execute(<span class="keyword">new</span> DelayedTaskConsumer(delayQueue));</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span> ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter ++ ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> delta ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> trigger ;</span><br><span class="line"> 	<span class="keyword">protected</span> <span class="keyword">static</span> List&lt;DelayedTask&gt; sequence = <span class="keyword">new</span> ArrayList&lt;DelayedTask&gt;();</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(<span class="keyword">int</span> delayInMilliseconds)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.delta = delayInMilliseconds ;</span><br><span class="line"> 		<span class="comment">// 从较细粒度到较粗粒度的舍位转换，这样会失去精确性。例如，将 999 毫秒转换为秒的结果为 0。</span></span><br><span class="line">                <span class="comment">// 使用参数从较粗粒度到较细粒度转换，如果参数为负，则在数字上溢出至 Long.MIN_VALUE，</span></span><br><span class="line">                <span class="comment">// 如果为正，则为 Long.MAX_VALUE。 将1毫秒转换为毫微秒</span></span><br><span class="line"> 		trigger = System.nanoTime() + TimeUnit.NANOSECONDS.convert(<span class="keyword">this</span>.delta, TimeUnit.MILLISECONDS);</span><br><span class="line"> 		sequence.add(<span class="keyword">this</span>) ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> unit.convert(trigger - System.nanoTime(), TimeUnit.NANOSECONDS);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed delayed)</span> </span>&#123;</span><br><span class="line"> 		DelayedTask task = (DelayedTask) delayed ;</span><br><span class="line"> 		<span class="keyword">if</span> (<span class="keyword">this</span>.delta &lt; task.delta) <span class="keyword">return</span> -<span class="number">1</span> ;</span><br><span class="line"> 		<span class="keyword">if</span> (<span class="keyword">this</span>.delta &gt; task.delta) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		System.out.println(<span class="keyword">this</span> + <span class="string">" "</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> String.format(<span class="string">"[%1$-4d]"</span>, delta) + <span class="string">" Task:"</span> + id;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> String <span class="title">summary</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">"("</span> + id + <span class="string">":"</span> + delta + <span class="string">")"</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndSentinel</span> <span class="keyword">extends</span> <span class="title">DelayedTask</span> </span>&#123;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="keyword">private</span> ExecutorService exec ;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="function"><span class="keyword">public</span> <span class="title">EndSentinel</span><span class="params">(<span class="keyword">int</span> delayInMilliseconds, ExecutorService exec)</span> </span>&#123;</span><br><span class="line"> 			<span class="keyword">super</span>(delayInMilliseconds);</span><br><span class="line"> 			<span class="keyword">this</span>.exec = exec ;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="meta">@Override</span></span><br><span class="line"> 		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 			<span class="keyword">for</span> (DelayedTask task : sequence) &#123;</span><br><span class="line"> 				System.out.print(task.summary() + <span class="string">" "</span>);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 			System.out.println();</span><br><span class="line"> 			System.out.println(<span class="keyword">this</span> + <span class="string">" Calling shutdownNow()"</span>);</span><br><span class="line"> 			exec.shutdownNow() ;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedTaskConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">private</span> DelayQueue&lt;DelayedTask&gt; q ;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">DelayedTaskConsumer</span><span class="params">(DelayQueue&lt;DelayedTask&gt; q)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.q = q ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			<span class="keyword">while</span> (!Thread.interrupted())&#123;</span><br><span class="line"> 				<span class="comment">//注意：手动调用run方法</span></span><br><span class="line"> 				q.take().run();</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line"> 		System.out.println(<span class="string">"Finish DelayedTaskConsumer"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">128</span> ] Task:<span class="number">11</span> </span><br><span class="line">[<span class="number">200</span> ] Task:<span class="number">7</span> </span><br><span class="line">[<span class="number">429</span> ] Task:<span class="number">5</span> </span><br><span class="line">[<span class="number">520</span> ] Task:<span class="number">18</span> </span><br><span class="line">[<span class="number">555</span> ] Task:<span class="number">1</span> </span><br><span class="line">[<span class="number">961</span> ] Task:<span class="number">4</span> </span><br><span class="line">[<span class="number">998</span> ] Task:<span class="number">16</span> </span><br><span class="line">[<span class="number">1207</span>] Task:<span class="number">9</span> </span><br><span class="line">[<span class="number">1693</span>] Task:<span class="number">2</span> </span><br><span class="line">[<span class="number">1809</span>] Task:<span class="number">14</span> </span><br><span class="line">[<span class="number">1861</span>] Task:<span class="number">3</span> </span><br><span class="line">[<span class="number">2278</span>] Task:<span class="number">15</span> </span><br><span class="line">[<span class="number">3288</span>] Task:<span class="number">10</span> </span><br><span class="line">[<span class="number">3551</span>] Task:<span class="number">12</span> </span><br><span class="line">[<span class="number">4258</span>] Task:<span class="number">0</span> </span><br><span class="line">[<span class="number">4258</span>] Task:<span class="number">19</span> </span><br><span class="line">[<span class="number">4522</span>] Task:<span class="number">8</span> </span><br><span class="line">[<span class="number">4589</span>] Task:<span class="number">13</span> </span><br><span class="line">[<span class="number">4861</span>] Task:<span class="number">17</span> </span><br><span class="line">[<span class="number">4868</span>] Task:<span class="number">6</span> </span><br><span class="line">(<span class="number">0</span>:<span class="number">4258</span>) (<span class="number">1</span>:<span class="number">555</span>) (<span class="number">2</span>:<span class="number">1693</span>) (<span class="number">3</span>:<span class="number">1861</span>) (<span class="number">4</span>:<span class="number">961</span>) (<span class="number">5</span>:<span class="number">429</span>) (<span class="number">6</span>:<span class="number">4868</span>) (<span class="number">7</span>:<span class="number">200</span>) (<span class="number">8</span>:<span class="number">4522</span>) (<span class="number">9</span>:<span class="number">1207</span>) (<span class="number">10</span>:<span class="number">3288</span>) (<span class="number">11</span>:<span class="number">128</span>) (<span class="number">12</span>:<span class="number">3551</span>) (<span class="number">13</span>:<span class="number">4589</span>) (<span class="number">14</span>:<span class="number">1809</span>) (<span class="number">15</span>:<span class="number">2278</span>) (<span class="number">16</span>:<span class="number">998</span>) (<span class="number">17</span>:<span class="number">4861</span>) (<span class="number">18</span>:<span class="number">520</span>) (<span class="number">19</span>:<span class="number">4258</span>) (<span class="number">20</span>:<span class="number">5000</span>) </span><br><span class="line">[<span class="number">5000</span>] Task:<span class="number">20</span> <span class="function">Calling <span class="title">shutdownNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Finish DelayedTaskConsumer</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/15/thread-tools-delayQueue/" data-id="ck2opn4k1002l0mewhxkut4k4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-outofMemroyError-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/15/JVM-outofMemroyError-02/" class="article-date">
  <time datetime="2018-06-15T07:09:30.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/15/JVM-outofMemroyError-02/">JVM学习2 - OutOfMemroyError***</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>1、OOM的概念</li>
<li>2、JVM堆内存溢出</li>
<li>3、JVM栈/Native栈内存溢出</li>
<li>4、方法区与常量池的内存溢出</li>
<li>5、本机直接内存溢出</li>
</ul>
<hr>
<h3 id="1、OOM的概念"><a href="#1、OOM的概念" class="headerlink" title="1、OOM的概念"></a>1、OOM的概念</h3><p>OOM便是OutOfMemroyError，它是一个异常错误，代表的意思便是JVM当中的内存不够用了，最终导致程序的Crash，这个问题不是有某一类的特定语法导致的，存在很多的情况，所以这种错误对于程序员来说还是相当的难解的，因为我们的内存回收工作是交给GC去做的，具体如何回收，我们不清楚，具体是JVM当中的哪一个区域发生的内存溢出，我们可以通过Log去分析，但是分析起来还是很费劲的，尤其是大型的系统，这便是OOM对程序员造成的痛。</p>
<h3 id="2、JVM堆内存溢出"><a href="#2、JVM堆内存溢出" class="headerlink" title="2、JVM堆内存溢出"></a>2、JVM堆内存溢出</h3><p>我们知道JVM堆当中存储的便是对象实例，那么只要我们不断的创建对象，并且保证GC Roots到对象之间有可达路径，用来避免垃圾回收机制清除这些对象，那么只要我们不断的new出新的对象，那么JVM虚拟机必然会出现内存溢出的异常。</p>
<p>这里通过三个参数来控制JVM堆内存的大小变化分别是</p>
<ul>
<li>Xsm：堆的最小值参数</li>
<li>-Xmx：堆的最大值参数</li>
<li>-XX: +HeapDumpOnOutOfMemoryError：可以让虚拟机在出现内存溢出异常时，Dump出当前的内存堆转储快照以便事后分析</li>
</ul>
<p>在Eclipse的Debug/Run页面，将堆的最小值和最大值都设置为20m，这样可以避免堆自动扩展。当我们设置完上面的参数值以后，我们通过一个Demo来看一下，如何造成堆内存溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 探究JVM 堆内存溢出，堆当中存储的是对象的实例，只要我们不断的new对象实例 就OK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengchengliu</span></span><br><span class="line"><span class="comment"> * JVM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line"> 		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"> 			list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid795.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">27575251</span> bytes in <span class="number">0.114</span> secs]</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line"> 	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line"> 	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br><span class="line"> 	at java.util.ArrayList.grow(ArrayList.java:<span class="number">261</span>)</span><br><span class="line"> 	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:<span class="number">235</span>)</span><br><span class="line"> 	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:<span class="number">227</span>)</span><br><span class="line"> 	at java.util.ArrayList.add(ArrayList.java:<span class="number">458</span>)</span><br><span class="line"> 	at outofmemoryerror.HeapOOM.main(HeapOOM.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure>
<p>当JVM堆当中出现OOM的异常还是比较常见的，当JVM当中出现堆内存溢出的时候。控制台上面便会抛出OOM异常，紧接着便会在后面出现 Java heap space 这样的字样，如果出现了这样的字样的时候，便可以得出当前的JVM堆现在状态便是内存溢出的状态。那么关于JVM堆内存溢出我们应该如何解决呢？ </p>
<p>分析</p>
<p>当这个区域当中出现了相应的OOM异常的时候，一般的手段便是先通过内存映像分析工具，对刚刚Dump出来的堆内存情况的快照进行分析，重点便是先确定内存当中的对象是否是必要的，也就是先分析清楚是内存泄露还是内存溢出。</p>
<ul>
<li><p>1、内存泄漏：如果可以确定是内存泄漏，可以进一步通过工具查看泄漏对象到GC Root的引用链，于是就能找到泄漏到泄漏对象是通过怎么的路径与GC Root相关联并且导致GC无法自动回收的，如果掌握了泄漏对象的类型信息以及GC root引用链的信息，就可以快速定位到泄漏代码的位置。</p>
</li>
<li><p>2、内存溢出：如果不是内存泄漏导致的，那就是纯粹的对象实例过多导致的，那么我们的第一步便是确定当前内存当中的所有对象是是否必须活着，如果不是，我们可以更改相应对象实例到GC Root的引用链的类型，如果是那就需要检查堆大小参数 -Xms -Xmx ，与物理内存进行对比看能否加大内存，从代码上面检查是否存在某些对象生命周期是否过长，持有的时间是否过长，减少程序运行期间内存的消耗。</p>
</li>
</ul>
<h3 id="3、JVM-栈-Native-栈-内存溢出"><a href="#3、JVM-栈-Native-栈-内存溢出" class="headerlink" title="3、JVM 栈 / Native 栈 内存溢出"></a>3、JVM 栈 / Native 栈 内存溢出</h3><p>首先这个区域JVM规范当中定义了两种内存溢出的异常</p>
<ul>
<li>如果线程请求的栈的深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常 (例如：错误的递归)</li>
<li>如果虚拟机在扩展时，无法申请到足够的内存空间，将抛出OOM异常 （例如：开启无限线程）</li>
</ul>
<p>我们可以通过 -Xoss 参数设置Native 栈的大小，通过-Xss 参数设置JVM栈的大小，但是在JVM众多的实现当中，有的虚拟机将上面两种栈结构通过了一种方式进行实现，导致使用-Xoss参数无法生效，那就只能使用-Xss进行设置。</p>
<p>下面通过一个Demo来演示想要的JVM栈内存溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 探究JVM栈深度OOM溢出</span></span><br><span class="line"><span class="comment"> * JVM args ： -Xss160k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengchengliu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStackOOM01</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span> ;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		stackLength ++ ;</span><br><span class="line"> 		stackLeak();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		JavaStackOOM01 javaStackOOM01 = <span class="keyword">new</span> JavaStackOOM01();</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			javaStackOOM01.stackLeak();</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"> 			System.out.println(<span class="string">"stack lenth :"</span> + javaStackOOM01.stackLength);</span><br><span class="line"> 			<span class="keyword">throw</span> e ;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line">stack lenth :<span class="number">771</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line"> 	at outofmemoryerror.JavaStackOOM01.stackLeak(JavaStackOOM01.java:<span class="number">14</span>)</span><br><span class="line"> 	at outofmemoryerror.JavaStackOOM01.stackLeak(JavaStackOOM01.java:<span class="number">15</span>)</span><br><span class="line"> 	at outofmemoryerror.JavaStackOOM01.stackLeak(JavaStackOOM01.java:<span class="number">15</span>)</span><br><span class="line"> 	at outofmemoryerror.JavaStackOOM01.stackLeak(JavaStackOOM01.java:<span class="number">15</span>)</span><br><span class="line"> 	at outofmemoryerror.JavaStackOOM01.stackLeak(JavaStackOOM01.java:<span class="number">15</span>)</span><br><span class="line">        …</span><br><span class="line">        at outofmemoryerror.JavaStackOOM01.main(JavaStackOOM01.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们使用默认的JVM栈的大小，那么递归的深度达到1000～2000是没有任何问题的，可以满足大多数情况下的递归调用，所以这种模式下面出现的溢出异常，我们可以不必要的进行深究。</p>
<p>下面演示一个通过线程数开辟栈的个数上线的时候出现的OOM异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 探究JVM栈大小OOM溢出</span></span><br><span class="line"><span class="comment"> * JVM args ： -Xss2m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengchengliu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStackOOM02</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"> 			Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"> 				<span class="meta">@Override</span></span><br><span class="line"> 				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 					dontStop();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;);</span><br><span class="line"> 			thread.start();</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		JavaStackOOM02 javaStackOOM02 = <span class="keyword">new</span> JavaStackOOM02();</span><br><span class="line"> 		javaStackOOM02.stackLeakByThread();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的这种做法还是会出现OOM异常的，这种方式在我们的日常开发当中还是比较常用的，如果遇到这种OOM，如果我们不能减少线程的数量活着更改64为虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。</p>
<h3 id="4、方法区与常量池的内存溢出"><a href="#4、方法区与常量池的内存溢出" class="headerlink" title="4、方法区与常量池的内存溢出"></a>4、方法区与常量池的内存溢出</h3><p>备注：剩下几种情况。 还未遇到， 遇到以后。第一时间更新</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/15/JVM-outofMemroyError-02/" data-id="ck2opn4i600000mewq9aimjx1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OutOfMemroy/">OutOfMemroy</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM-memory-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/03/JVM-memory-01/" class="article-date">
  <time datetime="2018-06-03T06:57:27.000Z" itemprop="datePublished">2018-06-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/03/JVM-memory-01/">JVM学习1 - 内存区域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>1、内存区域</li>
<li>2、JVM当中常用的内存区域</li>
<li>3、对象的内存格局</li>
<li>4、对象的访问定位</li>
<li>5、对象的创建过程</li>
</ul>
<hr>
<h3 id="1、内存区域"><a href="#1、内存区域" class="headerlink" title="1、内存区域"></a>1、内存区域</h3><p>对于一个程序来说，数据和指令就是该程序的全部。而这里所指的指令也就是开发人员所编写的代码，而数据便是一个程序的输入与输出。在一个大型的系统运行起来以后，便会有成千上万的数据来来回回的穿梭在整个系统当中，而这些数据来回穿梭的时候，会存储在什么地方呢？ 又是以何种形式进行存储。这便是本章节的重点。</p>
<p>数据在程序运行起来以后所存储的地方便是内存当中，而不同的数据类型存储在不同的内存区域当中。在我们开始学习编程的第一天便知道，C++这种语言是开发人员自己去管理自己的内存区域，而Java语言便是把内存的管理完全托管给了GC（Java当中的垃圾回收机制）。这样我们就不用去管内存当中的一些事情了，但是随着我们开发经验的不断增加，发现其实完全托管对于Java开发也不完全是好事，比如OOM，当内存溢出的时候，我们排查溢出点的难度将大大增加，如何提高自己排查关于内存方法的Bug呢。那便是研究JVM当中内存到底是如何分配的，如何由GC进行托管的。</p>
<h3 id="2、JVM内存区域"><a href="#2、JVM内存区域" class="headerlink" title="2、JVM内存区域"></a>2、JVM内存区域</h3><p>JVM当中把内存主要分为了7部分，想弄明白GC如何托管JVM的内存，那这7个内存区必须熟悉。下面了解一下这7个内存区域到底都是干什么的。</p>
<h4 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h4><p>这是一块很小的内存区域，同时这块内存可以被JVM快速的进行访问，里面存储这一个计数器，这个计数器用来表示当前这个程序执行到什么地方（.class文件的基础之上），如果理解起来比较费劲的话，可以理解为我们IDE当中deBug模式下的执行光标。</p>
<p>这个区域是所有区域当中最好理解的，就是告诉JVM，我们这个程序现在执行到了第几行，下面应该执行第几行。需要注意的便是在并发编程的时候，每一条线程都存在单独属于自己的程序计数器，因为如果微观的理解JVM并发编程的话，那么在一个确定的时刻，一个处理器都只会执行一条线程当中指令，这个时候线程调度器如何切换到了其他的线程，当前的计数器就应该保存在线程单独的内存当中好方便下次复位的时候继续执行。所以各条线程的程序计数器是相互独立的，我们称这类内存区域为“线程私有”的内存。有点类似于线程当中ThreadLocl<object>的概念</object></p>
<p>这一块内存是由JVM去统一管理，不管是插入还是删除，都和开发人员没有一点关系，所以这个地方的内存不会存在溢出的可能性。</p>
<h4 id="2、JVM栈"><a href="#2、JVM栈" class="headerlink" title="2、JVM栈"></a>2、JVM栈</h4><p>这一块内存区域当中存放的是方法，每个方法执行的时候，会创建一个栈帧，一个栈帧里面存放着执行方法所需要的数据，比如局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成对应着一个栈帧在JVM栈中入栈到出栈的全过程。其实好多Java开发人员对JVM栈的描述不完全，并不是存储这单一的对象引用，其实还有其他的信息，而我们理解的对象的引用是存放在局部变量表当中的。</p>
<p>局部变量表：主要存放着两个比较重要的内容分别是</p>
<ul>
<li>存放编译期可知的基本数据类型和对象的引用，对象的引用可能是对象实体起始地址的引用指针，也可能是一个代表对象的句柄</li>
<li>存放着returnAddress（指向了一条字节码指令的地址）<br>注意：存放基本数据类型区域当中，long和double会占2个局部变量空间，其余的只占一个。局部变量表所需的空间在编译期间完成分配。在运行期间不会改变当前局部变量表的大小</li>
</ul>
<p>JVM栈是线程私有的，生命周期和线程的生命周期一样。该区域如果线程请求的栈深度大于JVM所允许的深度，将抛出StackOverflowError的异常。也就是我们所说的无限递归调用，如果JVM栈是允许动态扩展的，如果申请不到足够的内存的时候，抛出OutOfMemoryError。</p>
<h4 id="3、Native-栈"><a href="#3、Native-栈" class="headerlink" title="3、Native 栈"></a>3、Native 栈</h4><p>这一块区域也别称为本地方法栈，该区域和上述的JVM栈非常相似，具体的区别便是JVM栈是为.class文件服务，而Native栈便是为Native方法服务，除了这一点没有什么不同，甚至有的JVM虚拟机在实现的时候，将JVM栈和Native栈进行了合并。</p>
<h4 id="4、JVM-堆"><a href="#4、JVM-堆" class="headerlink" title="4、JVM 堆"></a>4、JVM 堆</h4><p>这个块内存是JVM所管理的内存最大的一个区域，这个区域主要是用来存放对象实例，几乎所有的对象实例于数组都在该区域上面，但是随着科技的进步，不同的虚拟机有着不同的实现，导致了所有对象都分配在堆上面渐渐不是那么绝对了，该内存区域是被所有的线程所共享的，在JVM创建的时候创建。该区域上面可以处于物理上面不连续，但是只要逻辑上面是连续的即可。</p>
<p>JVM堆是GC重点的照顾对象，也被国人称为垃圾堆，JVM堆当中也会有很细小的划分，通过不同的划分条件，可以划分为不同的区域。如下：</p>
<ul>
<li>内存回收角度<ul>
<li>分代收集算法：新生代、老年代</li>
<li>细致划分：Eden空间、From Survivor空间、To Survivor空间</li>
</ul>
</li>
<li>内存分配角度<ul>
<li>多个线程共享的区域当中划分出多个线程私有的分配缓存区（Thread Locl Allocation Buffer，TLAB ）</li>
</ul>
</li>
</ul>
<p>当该区域的实在没有能力完成实例分配的时候，并且JVM堆再也没有办法进行扩展的时候，抛出OutOfMemoryError异常。</p>
<h4 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h4><p>这个区域按照JVM的规范来说应该是在JVM堆当中的，JVM堆当中存储的是对象实例，而这一块区域当中存储的是类的信息、常量、静态变量、即编译器编译以后的代码等数据，根据功能来说比较特殊，所以它有着一个别名叫做Non-Heap（非堆），所以就从堆当中独立出来的，但是基本属性还是和堆保持一致，比如这个区域是被所有线程所共享的。</p>
<p>这个区域GC的痕迹是比较少见的，但这不代表这进入这个区域的数据就会一直存在。这个区域的回收主要就是针对常量池和堆类型的卸载两个方面。当方法区当中无法满足内存分配需求的时候，将抛出OOM异常。</p>
<h4 id="6、常量池"><a href="#6、常量池" class="headerlink" title="6、常量池"></a>6、常量池</h4><p>这个区域是上述方法区当中的一个子区域，正如它的名字一样，这个区域当中存放着各种字面量和符号的引用，当一个类被加载后，这个类当中所描述的常量便会存入方法区的运行时常量池当中。</p>
<p>JVM规范当中对于一个class文件有着严格的规定，只有满足了JVM规范，JVM才会装载、执行。</p>
<p>一般常量池当中除了保存class文件中描述的符号引用，同时还会把翻译出来的直接引用也存储在这个区域当中。这个区域还有一个比较特殊的存在便是这个区域时在运行的时候进行管理的，也就是当动态的把一个class文件加载到了JVM上面，那么就会把class当中的常量动态的加载到方法区的常量池当中。这个区域是在方法区当中的，也就受限于方法区，当常量池无法再次申请到内存的时候就会抛出OOM异常。</p>
<h4 id="7、直接内存"><a href="#7、直接内存" class="headerlink" title="7、直接内存"></a>7、直接内存</h4><p>这个区域的内存其实不是JVM运行时数据区域的一部分，也不是Java虚拟机规范定义的内存区域。但是这部分内存也会被我们开发者频繁的进行使用，如果我们使用的方法有误，同样也会抛出OOM异常，这也就是我们需要了解它的原因之一吧。</p>
<p>我们知道在JDK1.4之后，Java为了提升IO的效率，引入了新的IO那便是NIO，NIO当中有一个概念便是基于Channel于Buffer的I/O方式，其实说白了就是它使用了Native函数库直接分配堆外内存，然后通过一个存储在Java堆上面的DirectByteBuffer对象所持有并且可以进行操作，这样便能显著的提升IO的效率，因为能避免Java堆和Native堆中来回复制数据</p>
<p>不属于JVM当中的内存肯定就不会收到JVM的限制，但是既然是内存，肯定还是会受到本机内存大小的限制，如果超出限制便会OOM</p>
<h3 id="3、对象的内存格局"><a href="#3、对象的内存格局" class="headerlink" title="3、对象的内存格局"></a>3、对象的内存格局</h3><p>一个对象的实例在JVM堆当中时以何种形式进行保存的？其实一个对象的实例在JVM堆当中是以三个部分进行保存的，下面我们来了解一下这三个部分</p>
<h4 id="1、对象头"><a href="#1、对象头" class="headerlink" title="1、对象头"></a>1、对象头</h4><p>对象头有点像一个进程在操作系统里面的PCB一样，里面存储该对象的控制属性（运行时数据），例如：哈希码、GC分代、锁状态标示、线程持有的锁、偏向线程ID、偏向时间戳等等，对象头的大小在JVM规范当中是有限制的，在32位JVM虚拟机上面时32位Bitmap结构所能记录的限度，64位虚拟机便是64位Bitmap所能记录的限度，官方称之为“Mark Work”。Mark Work被设计为一个非固定的数据结构以便在极小的空间内存存储尽量多的信息，会根据对象的状态复用自己的存储空间。</p>
<p>对象头的另外一个部分就是类型指针，即对象指向它的类元数据的指针，也就是在方法区的类元信息，JVM通过这个指针来确定这个对象是哪个类的实例。如果这个对象时数组，那么对象头当中还必须有一块用于记录数组长度的数据，因为JVM可以通过普通Java对象的元数据信息确认该Java对象的大小，但是从数组的元数据类型当中无法确认数组的大小。</p>
<h4 id="2、实例数据（Instance-Data）"><a href="#2、实例数据（Instance-Data）" class="headerlink" title="2、实例数据（Instance Data）"></a>2、实例数据（Instance Data）</h4><p>这部分内容就是我们定义的各种字段内容，也就是真正存储着的有效信息，包括从父类继承下来的，存储的顺序主要受两个方面的影响</p>
<ul>
<li>在Java源码当中的定义顺序</li>
<li>JVM的参数分配策略，分配策略主要是：longs/double、int、shorts/chars、bytes/boolean、oops（Ordinary Object Pointers）相同宽度的字段被分配到一起。</li>
</ul>
<p>在JVM分配策略满足的前提下，在父类中定义的变量会出现在子类之前。</p>
<h4 id="3、对齐填充"><a href="#3、对齐填充" class="headerlink" title="3、对齐填充"></a>3、对齐填充</h4><p>这部分的数据其实是没有任何意义的，仅仅起到了占位符的作用，由于JVM自动内存管理系统要求对象起始地址必须要是8个字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍，对象头的数据正好就是8字节的整数倍，但是当对象实例数据不足以是8字节的整数倍的时候，通过这部分数据填充补全。</p>
<h4 id="4、对象的访问定位"><a href="#4、对象的访问定位" class="headerlink" title="4、对象的访问定位"></a>4、对象的访问定位</h4><p>Java中，我们创建对象，就是为了使用这个对象，我们通过JVM栈中的局部变量表当中的对象的reference来操作在JVM堆上面的实例对象，JVM规范当中只规范了在局部变量表当中的reference应该指向JVM堆当中的对象实例，具体的如何指向没有说，这样的话，具体实现便由JVM的实现来规定，当前市面上面比较火的JVM虚拟机，主要通过以下两种方式进行实现</p>
<p>1、使用句柄来定位到对象</p>
<p>如果使用句柄来进行访问的话，Java堆当中将会划分出来一块内存作为句柄池，reference中存储这对象实例的地址说白了就是句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址，具体关系如下所示</p>
<p><img src="/2018/06/03/JVM-memory-01/JVM-memory-01.png" alt="使用句柄来定位到对象"></p>
<p>2、使用直接指针访问，在reference当中存储的直接就是对象的地址。如下所示：</p>
<p><img src="/2018/06/03/JVM-memory-01/JVM-memory-02.png" alt="使用直接指针访问"></p>
<p>总结：这两种对象访问方式又有优缺点，</p>
<ul>
<li>使用句柄的方式最大的好处便是reference中存储的信息是稳定的句柄地址，在对象实例数据被移动的时候（GC回收对象的时候必然会做到），只会改变句柄池当中实例数据的指针，而reference本身便不用修改</li>
<li>使用直接指针访问的好处在于速度是最快的，它节省了一次在句柄池当中定位的时间开销。</li>
</ul>
<p>具体使用哪一种方式进行使用，这遍取决于市面上面的JVM虚拟机，因为在JVM规范当中并没有明确说明应该如和去做。</p>
<h4 id="5、对象的创建过程"><a href="#5、对象的创建过程" class="headerlink" title="5、对象的创建过程"></a>5、对象的创建过程</h4><p>当虚拟机遇到我们源码当中的new关键字的时候，是如何进行工作，是如何进行内存的，这个过程到底是一个如何的过程，下面主要研究一下这一方面的知识</p>
<p>1、首先会去检查这个new这个指令的参数是否能够在常量池当中定位到一个类的符号引用，检查这个符号引用代表的类是否已被加载、解析和初始化过。</p>
<p>2、如果没有则先执行相应类加载过程。</p>
<p>3、在类加载检查通过了以后，JVM为新生的对象分为内存，（就是在JVM堆当中把一块确定的内存划分出来）对象所需内存的大小在类加载完成以后便可以完全确定的。</p>
<ul>
<li>3.1、假设堆当中的内存是绝对规整的，所有使用过的内存在一边，没有使用过的内存在另外一边，中间放着一个指针来作为绝对分界点的指示器，那所分配的内存就是仅仅把那个指针向空闲区域移动一段和对象大小相等的距离，这种分配方式叫做 Bump the Pointer 指针碰撞</li>
<li>3.2、假设堆当中的内存不是绝对规整的，JVM就必须维护一个列表，用来记录那块内存可以使用，那块内存不可以使用，在分配的时候找到一块足够大的空间划分给对象实例，并且更新表，这种方式被称为Free List 空闲列表</li>
</ul>
<p>具体使用哪一种方式进行内存分配，主要取决于当前堆当中的内存是否规整，而是否规整取决于GC是否带有压缩整理功能，如果有压缩整理功能的GC便使用 Bump the pointer 没有则使用 Free List</p>
<p>关于内存分配来说，会出现并发分配的情况，即把同一块内存分配给了A线程当中的某一个对象，和B线程当中的某一个对象。解决办法一般来说，有以下两种方式</p>
<ul>
<li>给JVM分配内存的动作进行同步处理，也就是加锁操作</li>
<li>每个线程在Java堆当中预先分配一小块内存，称为本地线程分配缓存（Thread Loacl Allocation Buffer TLAB）。那个线程要分配内存，就在那个线程的TLAB上面进行内存的分配，只有TLAB用完并分配新的TLAB的时候，才需要同步锁定，虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数进行控制</li>
</ul>
<p>4、内存分配完成以后，虚拟机需要将分配到的内存空间都初始化为0（不包括对象头），如果使用TLAB，这一个工作可以提前至TLAB进行分配的时候进行，这一操作便可以让Java代码在不赋初值的时候就可以直接使用</p>
<p>5、JVM对对象进行必要的初始化操作，就是初始化对象的对象头当中存储的信息</p>
<p>6、这个时候，当前对象便算是创建完成了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/03/JVM-memory-01/" data-id="ck2opn4jo001y0mew0c0rzkzg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-thread-tools-CyclicBarrier" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/29/thread-tools-CyclicBarrier/" class="article-date">
  <time datetime="2018-05-29T14:47:00.000Z" itemprop="datePublished">2018-05-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/并发/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/29/thread-tools-CyclicBarrier/">线程同步工具类CyclicBarrier</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>1、CyclicBarrier的作用</li>
<li>2、CyclicBarrier使用规则</li>
<li>3、CyclicBarrier的Demo</li>
<li>4、CyclicBarrier原理 (待补充)</li>
<li>5、CyclicBarrier的实现 （待补充）</li>
</ul>
<h3 id="1、CyclicBarrier的作用"><a href="#1、CyclicBarrier的作用" class="headerlink" title="1、CyclicBarrier的作用"></a>1、CyclicBarrier的作用</h3><p>CyclicBarrier类也是java提供给我们同步任务的时候使用的，和CountDownLatch有点类似，都是控制任务执行的顺序的，不同的地方在于，CyclicBarrier可以让一个任务在执行的途中发生多次事件，而CountDownLatch却只能发生一次，就是在我们调用countDown方法的时候，这个事件触发以后，便会减少相应的锁存器上面的计数器，而当计数器为0的时候，哪些调用了await的任务便可以执行了,但是CyclicBarrier就不同了，CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞</p>
<h3 id="2、CyclicBarrier的使用规则"><a href="#2、CyclicBarrier的使用规则" class="headerlink" title="2、CyclicBarrier的使用规则"></a>2、CyclicBarrier的使用规则</h3><p>CountDownLatch是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，再继续执行。<br>CyclicBarrier是一个同步的辅助类，允许一组线程相互之间等待，达到一个共同点，再继续执行。</p>
<p>个人理解：CyclicBarrier:可看成是个障碍，所有的线程必须到齐后才能一起通过这个障碍<br>场景还原：以前公司组织户外拓展活动，帮助团队建设，其中最重要一个项目就是全体员工（包括女同事，BOSS）在完成其他项目时，到达一个高达四米的高墙没有任何抓点，要求所有人，一个不能少的越过高墙，才能继续进行其他项目。</p>
<h3 id="3、CyclicBarrier的Demo"><a href="#3、CyclicBarrier的Demo" class="headerlink" title="3、CyclicBarrier的Demo"></a>3、CyclicBarrier的Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 探究CyclicBarrier的使用规则</span></span><br><span class="line"><span class="comment"> * 模拟赛马游戏</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengchengliu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCycilcBarrier</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINISH_LINE = <span class="number">100</span> ;</span><br><span class="line"> 	<span class="keyword">private</span> List&lt;Horse&gt; mHorses = <span class="keyword">new</span> ArrayList&lt;Horse&gt;() ;</span><br><span class="line"> 	<span class="keyword">private</span> ExecutorService mExec = Executors.newCachedThreadPool() ;</span><br><span class="line"> 	<span class="keyword">private</span> CyclicBarrier mCyclicBarrier ;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">TestCycilcBarrier</span> <span class="params">(<span class="keyword">int</span> horsesSize, <span class="keyword">int</span> pause)</span> </span>&#123;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">// "栏栅动作"，该动作为一个Runnable，这个Runnable在CyclicBarrier计数器变为0的时候执行。</span></span><br><span class="line"> 		mCyclicBarrier = <span class="keyword">new</span> CyclicBarrier(horsesSize, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> 			</span><br><span class="line"> 			<span class="meta">@Override</span></span><br><span class="line"> 			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 				StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"> 				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FINISH_LINE; i++) &#123;</span><br><span class="line"> 					stringBuilder.append(<span class="string">"="</span>);</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				System.out.println(stringBuilder);</span><br><span class="line"> 				</span><br><span class="line"> 				<span class="keyword">for</span> (Horse horse : mHorses) &#123;</span><br><span class="line"> 					System.out.println(horse.tracks());</span><br><span class="line"> 					<span class="keyword">if</span> (horse.getStrides() &gt;= FINISH_LINE) &#123;</span><br><span class="line"> 						System.out.println(horse + <span class="string">"won!"</span>);</span><br><span class="line"> 						mExec.shutdownNow();</span><br><span class="line"> 						<span class="keyword">return</span> ;</span><br><span class="line"> 					&#125;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				<span class="keyword">try</span> &#123;</span><br><span class="line"> 					TimeUnit.MILLISECONDS.sleep(pause);</span><br><span class="line"> 				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> 					System.out.println(<span class="string">"barrier-action sleep interrupted"</span>);</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;);</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; horsesSize; i++) &#123;</span><br><span class="line"> 			Horse horse = <span class="keyword">new</span> Horse(mCyclicBarrier);</span><br><span class="line"> 			mHorses.add(horse);</span><br><span class="line"> 			mExec.execute(horse);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">int</span> horsesSize = <span class="number">10</span> ;</span><br><span class="line"> 		<span class="keyword">int</span> pause = <span class="number">200</span> ;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> 			Integer temp = <span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line"> 			horsesSize = temp &gt; <span class="number">0</span> ? temp : horsesSize ;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="keyword">if</span> (args.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line"> 			Integer temp = <span class="keyword">new</span> Integer(args[<span class="number">1</span>]);</span><br><span class="line"> 			pause = temp &gt; <span class="number">0</span> ? temp : pause ;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="keyword">new</span> TestCycilcBarrier(horsesSize, pause);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sCounter = <span class="number">0</span> ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ID = sCounter ++ ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> mStrides = <span class="number">0</span> ;</span><br><span class="line"> 	<span class="keyword">private</span> Random mRandom = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier sBarrier ;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Horse</span> <span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.sBarrier = cyclicBarrier ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			<span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line"> 				<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"> 					mStrides += mRandom.nextInt(<span class="number">5</span>);</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				sBarrier.await();</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> 			</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line"> 			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e) ;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getStrides</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> mStrides ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">"Horse  "</span> + <span class="keyword">this</span>.ID ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> String <span class="title">tracks</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"> 		StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getStrides(); i++) &#123;</span><br><span class="line"> 			stringBuffer.append(<span class="string">"-"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		stringBuffer.append(<span class="keyword">this</span>.ID);</span><br><span class="line"> 		<span class="keyword">return</span> stringBuffer.toString() ;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述Demo运行起来的效果图，如下图所示：</p>
<p><img src="/2018/05/29/thread-tools-CyclicBarrier/horese.gif" alt="赛马游戏"></p>
<p>参考文献</p>
<ul>
<li><a href="https://blog.csdn.net/zzg1229059735/article/details/61191679" target="_blank" rel="noopener">https://blog.csdn.net/zzg1229059735/article/details/61191679</a></li>
<li><a href="http://ifeve.com/concurrency-cyclicbarrier/" target="_blank" rel="noopener">http://ifeve.com/concurrency-cyclicbarrier/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/29/thread-tools-CyclicBarrier/" data-id="ck2opn4j0000r0mewmla7y6tu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-thread-tools-CountDownLatch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/29/thread-tools-CountDownLatch/" class="article-date">
  <time datetime="2018-05-29T14:44:00.000Z" itemprop="datePublished">2018-05-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/并发/">并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/29/thread-tools-CountDownLatch/">线程同步工具类CountDownLatch</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>1、CountDownLatch的作用</li>
<li>2、CountDownLatch使用规则</li>
<li>3、CountDownLatch的Demo</li>
<li>4、CountDownLatch原理  (待补充)</li>
<li>5、CountDownLatch的实现 （待补充）</li>
</ul>
<hr>
<h3 id="1、CountDownLatch的作用"><a href="#1、CountDownLatch的作用" class="headerlink" title="1、CountDownLatch的作用"></a>1、CountDownLatch的作用</h3><p>在JDK 5 以后sun公司引入了大量设计来解决并发的问题，学习使用这些类，我们可以更加自如的创建简单而健壮的并发程序，CountDownLatch类是用来同步一个或者多个任务的工具类，强制它们等待由其他任务执行的一组操作。</p>
<p>例如，现在有这样的一个需求，为了程序的快速运行，我们把一个程序分为三部分，分别是初始化、数据拉取、显示数据。初始化操作和数据拉取操作不会冲突，可以说这两个操作完全不相关，但是显示数据必须要在上面两个任务完成以后才可以继续。如果把这三个操作至于不同的线程，那么如果不对线程的同步加以控制的话，必将大乱，这个时候我们就可以先对CountDownLatct初始计数器为2，然后让初始化操作和数据拉取操作开始运行，然后在结束的时候调用countDown方法，然后显示操作在run开始的时候使用awit进行等待，直到计数器归0，显示操作开始执行，而这个时候上述两个操作都已经执行完毕。</p>
<h3 id="2、CountDownLatch的使用规则"><a href="#2、CountDownLatch的使用规则" class="headerlink" title="2、CountDownLatch的使用规则"></a>2、CountDownLatch的使用规则</h3><p>我们可以向CountDownLatch对象设置一个初始计数值，任何在CountDownLatch对象上调用wait的方法都将被阻塞，直到这个计数器达到0。其他任务在结束其工作时，可以在该对象上调用countDown（）来减少这个计数器。CountDownLatch被设计为只触发一次，计数器不能被重置。</p>
<p>调用countDown的任务在产生这个调用时并没有被阻塞，只有对await的调用会产生阻塞，直到计数器达到0为止。</p>
<p>CountDownLatch的典型用法是将一个程序分为n个互相独立的可以解决的任务，并创建值为0的CountDownLatch。当每个任务完成时，都会在这个锁存器上调用countDown。等待问题被解决的任务在这个锁存器上面调用await，将它们自己揽住，直至锁存器计数结束，下面通过一个例子来演示该框架应该如何应用。</p>
<p>个人理解：CountDownLatch:我把他理解成倒计时锁<br>场景还原：一年级期末考试要开始了，监考老师发下去试卷，然后坐在讲台旁边玩着手机等待着学生答题，有的学生提前交了试卷，并约起打球了，等到最后一个学生交卷了，老师开始整理试卷，贴封条，下班，陪老婆孩子去了。<br>补充场景：我们在玩LOL英雄联盟时会出现十个人不同加载状态，但是最后一个人由于各种原因始终加载不了100%，于是游戏系统自动等待所有玩家的状态都准备好，才展现游戏画面。</p>
<h3 id="3、CountDownLatch的Demo"><a href="#3、CountDownLatch的Demo" class="headerlink" title="3、CountDownLatch的Demo"></a>3、CountDownLatch的Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示CountDownLatch的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengchengliu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span> ;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"> 		CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(SIZE);</span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> 			exec.execute(<span class="keyword">new</span> WaitingTask(countDownLatch));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line"> 			exec.execute(<span class="keyword">new</span> TaskProtion(countDownLatch));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		System.out.println(<span class="string">"Launch all task"</span>);</span><br><span class="line"> 		exec.shutdown();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskProtion</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sCounter = <span class="number">0</span> ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = sCounter ++ ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> Random sRandom = <span class="keyword">new</span> Random(<span class="number">47</span>) ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch mLatch ;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">TaskProtion</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.mLatch = latch ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			doWork();</span><br><span class="line"> 			mLatch.countDown();</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> 			System.out.println(<span class="string">"TaskProtion is exiting form intrrupt"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> 		TimeUnit.MICROSECONDS.sleep(sRandom.nextInt(<span class="number">2000</span>));</span><br><span class="line"> 		System.out.println(<span class="keyword">this</span> + <span class="string">" completed"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> String.format(<span class="string">"%1$-3d"</span>, id);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitingTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sCounter = <span class="number">0</span> ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = sCounter ++ ;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch mLatch ;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">WaitingTask</span> <span class="params">(CountDownLatch latch)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.mLatch = latch ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">try</span> &#123;</span><br><span class="line"> 			<span class="keyword">this</span>.mLatch.await();</span><br><span class="line"> 			System.out.println(<span class="string">"Latch barrier passed for "</span> + <span class="keyword">this</span>);</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> 			System.out.println(<span class="keyword">this</span> + <span class="string">" interrupted"</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> String.format(<span class="string">"WaitingTask %1$-3d"</span>, id);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Launch all task</span><br><span class="line"><span class="number">2</span>   completed</span><br><span class="line"><span class="number">8</span>   completed</span><br><span class="line"><span class="number">6</span>   completed</span><br><span class="line"><span class="number">5</span>   completed</span><br><span class="line"><span class="number">3</span>   completed</span><br><span class="line"><span class="number">9</span>   completed</span><br><span class="line"><span class="number">4</span>   completed</span><br><span class="line"><span class="number">0</span>   completed</span><br><span class="line"><span class="number">7</span>   completed</span><br><span class="line"><span class="number">1</span>   completed</span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">3</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">6</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">0</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">1</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">8</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">9</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">7</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">2</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">4</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>通过上述的任务输出，我们不难看出，我们将我们的任务很整齐的进行了先后顺序的控制，让我们程序当中有预支条件的任务可以在预支条件之后进行运行。这里就是通过CountDownLatch的锁存器当中的计数器来控制的。这里需要注意的两点就是，</p>
<ul>
<li>CountDownLatch这个类当中的计数器的初始值，只能被初始化一次，不能初始化第二次，</li>
<li>在使用的时候，必须多个对象同步同一个CountDownLatch这个类。</li>
</ul>
<p>我们可以尝试将上述代码当中的CountDownLatch相关操作去除，我们再来看一下运行结果，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Launch all task</span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">9</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">1</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">2</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">8</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">5</span>  </span><br><span class="line"><span class="number">9</span>   completed</span><br><span class="line"><span class="number">2</span>   completed</span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">6</span>  </span><br><span class="line"><span class="number">5</span>   completed</span><br><span class="line"><span class="number">8</span>   completed</span><br><span class="line"><span class="number">3</span>   completed</span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">3</span>  </span><br><span class="line"><span class="number">1</span>   completed</span><br><span class="line"><span class="number">6</span>   completed</span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">4</span>  </span><br><span class="line"><span class="number">7</span>   completed</span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">7</span>  </span><br><span class="line">Latch barrier passed <span class="keyword">for</span> WaitingTask <span class="number">0</span>  </span><br><span class="line"><span class="number">0</span>   completed</span><br><span class="line"><span class="number">4</span>   completed</span><br></pre></td></tr></table></figure>
<p>很明显结果杂乱无章，没有任何规律可言，到这里大家应该明白了CountDownLatch类的使用了吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/29/thread-tools-CountDownLatch/" data-id="ck2opn4iy000n0mewfdjpmu1k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>
</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a href="/" class="logo">刘鹏程</a>
      &copy; 2019 刘鹏程<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>